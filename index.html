<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>一尘的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="一尘的个人博客">
<meta property="og:url" content="https://yichen10.github.io/index.html">
<meta property="og:site_name" content="一尘的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yichen">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="一尘的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">一尘的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yichen10.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-面试5-spring基础相关" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/05/%E9%9D%A2%E8%AF%955-spring%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/" class="article-date">
  <time class="dt-published" datetime="2024-11-05T02:02:54.000Z" itemprop="datePublished">2024-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/05/%E9%9D%A2%E8%AF%955-spring%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/">面试5-spring基础相关</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Spring 框架中的 Bean 生命周期是指 Bean 从创建到销毁的整个过程。Spring 提供了丰富的回调机制和接口，使得开发者可以在 Bean 生命周期的不同阶段执行自定义的初始化和销毁逻辑。</p>
<h3 id="Spring-Bean-生命周期概述"><a href="#Spring-Bean-生命周期概述" class="headerlink" title="Spring Bean 生命周期概述"></a>Spring Bean 生命周期概述</h3><p>Spring Bean 的生命周期可以分为以下几个主要阶段：</p>
<ol>
<li><strong>实例化（Instantiation）</strong></li>
<li><strong>属性赋值（Populate Properties）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li><strong>使用（In Use）</strong></li>
<li><strong>销毁（Destruction）</strong></li>
</ol>
<h3 id="详细的生命周期步骤"><a href="#详细的生命周期步骤" class="headerlink" title="详细的生命周期步骤"></a>详细的生命周期步骤</h3><ol>
<li><p><strong>实例化（Instantiation）</strong></p>
<ul>
<li>Spring 容器根据配置创建 Bean 的实例。</li>
</ul>
</li>
<li><p><strong>属性赋值（Populate Properties）</strong></p>
<ul>
<li>Spring 容器将配置文件或注解中定义的属性值注入到 Bean 实例中。</li>
</ul>
</li>
<li><p><strong>BeanNameAware 接口</strong></p>
<ul>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，Spring 容器会调用 <code>setBeanName(String name)</code> 方法，传递 Bean 的名称。</li>
</ul>
</li>
<li><p><strong>BeanFactoryAware 接口</strong></p>
<ul>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，Spring 容器会调用 <code>setBeanFactory(BeanFactory beanFactory)</code> 方法，传递 BeanFactory 实例。</li>
</ul>
</li>
<li><p><strong>ApplicationContextAware 接口</strong></p>
<ul>
<li>如果 Bean 实现了 <code>ApplicationContextAware</code> 接口，Spring 容器会调用 <code>setApplicationContext(ApplicationContext applicationContext)</code> 方法，传递 ApplicationContext 实例。</li>
</ul>
</li>
<li><p><strong>BeanPostProcessor 前置处理</strong></p>
<ul>
<li>Spring 容器调用所有 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization(Object bean, String beanName)</code> 方法，对 Bean 进行前置处理。</li>
</ul>
</li>
<li><p><strong>InitializingBean 接口</strong></p>
<ul>
<li>如果 Bean 实现了 <code>InitializingBean</code> 接口，Spring 容器会调用 <code>afterPropertiesSet()</code> 方法。</li>
</ul>
</li>
<li><p><strong>自定义初始化方法</strong></p>
<ul>
<li>Spring 容器调用配置中指定的自定义初始化方法（如 <code>@PostConstruct</code> 注解或 XML 配置中的 <code>init-method</code>）。</li>
</ul>
</li>
<li><p><strong>BeanPostProcessor 后置处理</strong></p>
<ul>
<li>Spring 容器调用所有 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization(Object bean, String beanName)</code> 方法，对 Bean 进行后置处理。</li>
</ul>
</li>
<li><p><strong>使用（In Use）</strong></p>
<ul>
<li>Bean 处于可用状态，可以被应用程序使用。</li>
</ul>
</li>
<li><p><strong>DisposableBean 接口</strong></p>
<ul>
<li>如果 Bean 实现了 <code>DisposableBean</code> 接口，Spring 容器会在 Bean 销毁时调用 <code>destroy()</code> 方法。</li>
</ul>
</li>
<li><p><strong>自定义销毁方法</strong></p>
<ul>
<li>Spring 容器调用配置中指定的自定义销毁方法（如 <code>@PreDestroy</code> 注解或 XML 配置中的 <code>destroy-method</code>）。</li>
</ul>
</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个示例，展示了如何在 Spring Bean 生命周期的不同阶段执行自定义逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1. Bean 实例化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;2. BeanNameAware: Bean 名称 - &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">        System.out.println(<span class="string">&quot;3. ApplicationContextAware: ApplicationContext 设置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postConstruct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5. @PostConstruct: 自定义初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4. InitializingBean: afterPropertiesSet 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customInitMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;6. 自定义初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;7. 使用 Bean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;8. @PreDestroy: 自定义销毁方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9. DisposableBean: destroy 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customDestroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;10. 自定义销毁方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在 Spring 配置文件中，可以指定自定义的初始化和销毁方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;customInitMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;customDestroyMethod&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring Bean 生命周期提供了丰富的回调机制，使得开发者可以在 Bean 的不同阶段执行自定义逻辑。通过实现特定的接口或使用注解，可以轻松地在 Bean 的初始化和销毁阶段添加自定义行为。</p>
<p>Spring 框架提供了强大的事务管理功能，使得开发者可以轻松地在应用程序中实现事务管理。Spring 事务管理的核心是基于 AOP（面向切面编程）和事务管理器（TransactionManager）。Spring 支持多种事务管理方式，包括声明式事务管理和编程式事务管理。</p>
<h3 id="Spring-事务管理的核心组件"><a href="#Spring-事务管理的核心组件" class="headerlink" title="Spring 事务管理的核心组件"></a>Spring 事务管理的核心组件</h3><ol>
<li><p><strong>PlatformTransactionManager</strong>:</p>
<ul>
<li>这是 Spring 事务管理的核心接口，定义了事务管理的基本操作，如 <code>getTransaction()</code>、<code>commit()</code> 和 <code>rollback()</code>。</li>
<li>Spring 提供了多种实现类，如 <code>DataSourceTransactionManager</code>、<code>JtaTransactionManager</code> 等，用于不同的数据访问技术。</li>
</ul>
</li>
<li><p><strong>TransactionDefinition</strong>:</p>
<ul>
<li>定义了事务的属性，如隔离级别、传播行为、超时时间和只读标志。</li>
</ul>
</li>
<li><p><strong>TransactionStatus</strong>:</p>
<ul>
<li>表示事务的当前状态，提供了一些方法来检查事务的状态和执行回滚操作。</li>
</ul>
</li>
</ol>
<h3 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h3><p>声明式事务管理是 Spring 中最常用的事务管理方式，它允许开发者通过配置来定义事务边界，而不需要编写大量的样板代码。</p>
<h4 id="使用-XML-配置"><a href="#使用-XML-配置" class="headerlink" title="使用 XML 配置"></a>使用 XML 配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;serviceOperation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.example.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;serviceOperation&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用注解配置"><a href="#使用注解配置" class="headerlink" title="使用注解配置"></a>使用注解配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Spring 配置类中启用事务管理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><p>编程式事务管理允许开发者通过编写代码来显式地控制事务的开始、提交和回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.DefaultTransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">TransactionDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(def);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userRepository.save(user);</span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p>Spring 支持多种事务传播行为，定义了事务方法调用时的事务行为：</p>
<ul>
<li><strong>REQUIRED</strong>: 如果当前存在事务，则加入该事务；否则创建一个新事务。</li>
<li><strong>REQUIRES_NEW</strong>: 创建一个新事务，如果当前存在事务，则挂起当前事务。</li>
<li><strong>SUPPORTS</strong>: 如果当前存在事务，则加入该事务；否则以非事务方式执行。</li>
<li><strong>NOT_SUPPORTED</strong>: 以非事务方式执行操作，如果当前存在事务，则挂起当前事务。</li>
<li><strong>MANDATORY</strong>: 如果当前存在事务，则加入</li>
</ul>
<p>AOP（Aspect-Oriented Programming，面向切面编程）和 OOP（Object-Oriented Programming，面向对象编程）是两种不同的编程范式，它们各自解决不同的问题，但在实际应用中常常结合使用，以提高代码的可维护性和可扩展性。</p>
<h3 id="1-面向对象编程（OOP）"><a href="#1-面向对象编程（OOP）" class="headerlink" title="1. 面向对象编程（OOP）"></a>1. 面向对象编程（OOP）</h3><p><strong>OOP 的核心概念</strong>：</p>
<ul>
<li><strong>封装（Encapsulation）</strong>：将数据和操作数据的方法封装在一起，隐藏内部实现细节，只暴露必要的接口。</li>
<li><strong>继承（Inheritance）</strong>：通过继承机制，子类可以继承父类的属性和方法，从而实现代码复用。</li>
<li><strong>多态（Polymorphism）</strong>：允许不同类的对象对同一消息做出响应，通过方法重载和方法重写实现。</li>
<li><strong>抽象（Abstraction）</strong>：通过抽象类和接口定义对象的行为，隐藏具体实现细节。</li>
</ul>
<p><strong>OOP 的优势</strong>：</p>
<ul>
<li><strong>代码复用</strong>：通过继承和组合实现代码复用。</li>
<li><strong>模块化</strong>：将系统分解为多个对象，每个对象负责特定的功能。</li>
<li><strong>可维护性</strong>：通过封装和抽象，降低代码的耦合度，提高可维护性。</li>
</ul>
<p><strong>OOP 的局限性</strong>：</p>
<ul>
<li><strong>横切关注点</strong>：OOP 难以处理横切关注点（cross-cutting concerns），如日志记录、事务管理、安全性检查等。这些关注点在多个模块中重复出现，导致代码冗余和难以维护。</li>
</ul>
<h3 id="2-面向切面编程（AOP）"><a href="#2-面向切面编程（AOP）" class="headerlink" title="2. 面向切面编程（AOP）"></a>2. 面向切面编程（AOP）</h3><p><strong>AOP 的核心概念</strong>：</p>
<ul>
<li><strong>切面（Aspect）</strong>：一个模块化的横切关注点，通常包含通知（Advice）和切点（Pointcut）。</li>
<li><strong>通知（Advice）</strong>：在特定的连接点（Join Point）执行的代码，例如在方法执行前、执行后、抛出异常时执行的代码。</li>
<li><strong>切点（Pointcut）</strong>：定义了通知应该在哪些连接点上执行。</li>
<li><strong>连接点（Join Point）</strong>：程序执行过程中的一个点，例如方法调用、异常抛出等。</li>
<li><strong>目标对象（Target Object）</strong>：被代理的对象，即应用了切面的对象。</li>
<li><strong>代理（Proxy）</strong>：在目标对象上应用了切面逻辑后生成的对象。</li>
</ul>
<p><strong>AOP 的优势</strong>：</p>
<ul>
<li><strong>分离关注点</strong>：将横切关注点与业务逻辑分离，提高代码的模块化和可维护性。</li>
<li><strong>减少代码冗余</strong>：横切关注点的代码只需编写一次，然后在多个地方应用。</li>
<li><strong>提高可扩展性</strong>：通过切面，可以在不修改原有代码的情况下，增加新的功能。</li>
</ul>
<p><strong>AOP 的局限性</strong>：</p>
<ul>
<li><strong>复杂性</strong>：AOP 引入了新的概念和机制，增加了代码的复杂性。</li>
<li><strong>性能开销</strong>：AOP 代理机制可能会引入一定的性能开销。</li>
</ul>
<h3 id="3-AOP-与-OOP-的关系"><a href="#3-AOP-与-OOP-的关系" class="headerlink" title="3. AOP 与 OOP 的关系"></a>3. AOP 与 OOP 的关系</h3><ul>
<li><strong>互补关系</strong>：AOP 和 OOP 是互补的编程范式。OOP 提供了对象和类的抽象，而 AOP 提供了横切关注点的抽象。</li>
<li><strong>结合使用</strong>：在实际应用中，AOP 和 OOP 常常结合使用。通过 AOP，可以将横切关注点从业务逻辑中分离出来，而通过 OOP，可以实现对象和类的抽象。</li>
</ul>
<h3 id="4-示例说明"><a href="#4-示例说明" class="headerlink" title="4. 示例说明"></a>4. 示例说明</h3><p>假设我们有一个服务类 <code>UserService</code>，我们希望在它的方法执行前后记录日志。</p>
<h4 id="1-使用-OOP-实现"><a href="#1-使用-OOP-实现" class="headerlink" title="1. 使用 OOP 实现"></a>1. 使用 OOP 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        logBefore(<span class="string">&quot;createUser&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating user: &quot;</span> + username);</span><br><span class="line">        logAfter(<span class="string">&quot;createUser&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before &quot;</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After &quot;</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，日志记录代码与业务逻辑代码混合在一起，导致代码冗余和难以维护。</p>
<h4 id="2-使用-AOP-实现"><a href="#2-使用-AOP-实现" class="headerlink" title="2. 使用 AOP 实现"></a>2. 使用 AOP 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method execution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.example.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After method execution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Spring 配置中，我们需要启用 AOP 和组件扫描：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过依赖注入，我们可以获取 <code>UserService</code> 的代理对象并使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        userService.createUser(<span class="string">&quot;JohnDoe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before method execution</span><br><span class="line">Creating user: JohnDoe</span><br><span class="line">After method execution</span><br></pre></td></tr></table></figure>

<p>在这个例子中，日志记录代码被分离到 <code>LoggingAspect</code> 中，与业务逻辑代码解耦，提高了代码的可维护性和可扩展性。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>面向对象编程（OOP）</strong>：通过封装、继承、多态和抽象，实现对象和类的抽象，提高代码的模块化和可维护性。</li>
<li><strong>面向切面编程（AOP）</strong>：通过切面、通知、切点和连接点，实现横切关注点的抽象，提高代码的模块化和可维护性。</li>
<li><strong>互补关系</strong>：AOP 和 OOP 是互补的编程范式，在实际应用中常常结合使用，以提高代码的可维护性和可扩展性。</li>
</ul>
<p>通过理解和应用这两种编程范式，可以显著提高代码的可维护性和可扩展性。</p>
<p>Spring AOP（Aspect-Oriented Programming）和依赖注入（Dependency Injection，简称DI）是Spring框架中的两个核心概念，它们分别解决了不同的问题，但在实际应用中常常结合使用。</p>
<h3 id="1-Spring-AOP（面向切面编程）"><a href="#1-Spring-AOP（面向切面编程）" class="headerlink" title="1. Spring AOP（面向切面编程）"></a>1. Spring AOP（面向切面编程）</h3><p><strong>AOP的概念</strong>：<br>AOP是一种编程范式，旨在将横切关注点（cross-cutting concerns）与业务逻辑分离。横切关注点是指那些在多个模块中重复出现的代码，例如日志记录、事务管理、安全性检查等。通过AOP，可以将这些横切关注点从业务逻辑中分离出来，使得代码更加模块化和易于维护。</p>
<p><strong>AOP的核心概念</strong>：</p>
<ul>
<li><strong>切面（Aspect）</strong>：一个模块化的横切关注点，通常包含通知（Advice）和切点（Pointcut）。</li>
<li><strong>通知（Advice）</strong>：在特定的连接点（Join Point）执行的代码，例如在方法执行前、执行后、抛出异常时执行的代码。</li>
<li><strong>切点（Pointcut）</strong>：定义了通知应该在哪些连接点上执行。</li>
<li><strong>连接点（Join Point）</strong>：程序执行过程中的一个点，例如方法调用、异常抛出等。</li>
<li><strong>目标对象（Target Object）</strong>：被代理的对象，即应用了切面的对象。</li>
<li><strong>代理（Proxy）</strong>：在目标对象上应用了切面逻辑后生成的对象。</li>
</ul>
<p><strong>AOP的实现方式</strong>：</p>
<ul>
<li><strong>基于JDK动态代理</strong>：适用于实现了接口的目标对象。</li>
<li><strong>基于CGLIB代理</strong>：适用于没有实现接口的目标对象。</li>
</ul>
<p><strong>AOP的应用场景</strong>：</p>
<ul>
<li>日志记录</li>
<li>事务管理</li>
<li>安全性检查</li>
<li>性能监控</li>
</ul>
<h3 id="2-依赖注入（Dependency-Injection）"><a href="#2-依赖注入（Dependency-Injection）" class="headerlink" title="2. 依赖注入（Dependency Injection）"></a>2. 依赖注入（Dependency Injection）</h3><p><strong>DI的概念</strong>：<br>依赖注入是一种设计模式，用于实现控制反转（Inversion of Control，简称IoC）。通过依赖注入，对象的依赖关系由外部容器（如Spring容器）在运行时动态注入，而不是由对象自己创建或查找依赖。</p>
<p><strong>DI的核心概念</strong>：</p>
<ul>
<li><strong>依赖（Dependency）</strong>：一个对象所依赖的其他对象。</li>
<li><strong>注入（Injection）</strong>：将依赖对象传递给目标对象的过程。</li>
<li><strong>容器（Container）</strong>：负责管理对象的生命周期和依赖关系的容器，如Spring的ApplicationContext。</li>
</ul>
<p><strong>DI的实现方式</strong>：</p>
<ul>
<li><strong>构造器注入（Constructor Injection）</strong>：通过构造函数注入依赖。</li>
<li><strong>Setter注入（Setter Injection）</strong>：通过Setter方法注入依赖。</li>
<li><strong>字段注入（Field Injection）</strong>：通过反射直接注入字段（不推荐，因为破坏了封装性）。</li>
</ul>
<p><strong>DI的优势</strong>：</p>
<ul>
<li>降低耦合度：对象不需要知道如何创建或查找依赖。</li>
<li>提高可测试性：依赖可以被替换为测试替身（如Mock对象）。</li>
<li>代码复用：相同的依赖可以在多个对象之间共享。</li>
</ul>
<h3 id="3-Spring-AOP与依赖注入的关系"><a href="#3-Spring-AOP与依赖注入的关系" class="headerlink" title="3. Spring AOP与依赖注入的关系"></a>3. Spring AOP与依赖注入的关系</h3><ul>
<li><strong>结合使用</strong>：Spring AOP和依赖注入通常结合使用。依赖注入负责管理对象的生命周期和依赖关系，而AOP则负责处理横切关注点。</li>
<li><strong>AOP代理</strong>：在Spring中，AOP代理通常是通过依赖注入创建的。Spring容器会自动为应用了切面的目标对象创建代理，并将代理对象注入到需要的地方。</li>
<li><strong>事务管理</strong>：Spring的事务管理就是一个典型的AOP应用。通过AOP，Spring可以在方法调用前后自动开启、提交或回滚事务，而无需在业务逻辑中显式处理事务。</li>
</ul>
<h3 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h3><p>假设我们有一个服务类<code>UserService</code>，我们希望在它的方法执行前后记录日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating user: &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过AOP来实现日志记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method execution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.example.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After method execution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring配置中，我们需要启用AOP和组件扫描：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过依赖注入，我们可以获取<code>UserService</code>的代理对象并使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        userService.createUser(<span class="string">&quot;JohnDoe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before method execution</span><br><span class="line">Creating user: JohnDoe</span><br><span class="line">After method execution</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>UserService</code>的<code>createUser</code>方法被AOP代理拦截，并在方法执行前后记录了日志。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Spring AOP</strong>：用于处理横切关注点，将这些关注点与业务逻辑分离。</li>
<li><strong>依赖注入</strong>：用于管理对象的依赖关系，降低耦合度。</li>
<li><strong>结合使用</strong>：在Spring中，AOP和DI通常结合使用，AOP代理通过DI创建并注入到需要的地方。</li>
</ul>
<p>通过理解和应用这两个概念，可以显著提高代码的可维护性和可扩展性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yichen10.github.io/2024/11/05/%E9%9D%A2%E8%AF%955-spring%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/" data-id="cm33t3dq40000bwbz195sd2gs" data-title="面试5-spring基础相关" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/05/%E9%9D%A2%E8%AF%954/" class="article-date">
  <time class="dt-published" datetime="2024-11-05T01:22:16.000Z" itemprop="datePublished">2024-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/05/%E9%9D%A2%E8%AF%954/">面试4</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>synchronized</code> 是 Java 中用于实现线程同步的关键字，它可以确保在同一时刻只有一个线程可以访问被保护的代码块或方法。<code>synchronized</code> 的底层原理主要涉及 Java 对象头中的锁信息和 JVM 的锁机制。以下是 <code>synchronized</code> 关键字的底层原理的详细解释：</p>
<h3 id="1-Java-对象头"><a href="#1-Java-对象头" class="headerlink" title="1. Java 对象头"></a>1. <strong>Java 对象头</strong></h3><p>在 Java 中，每个对象都有一个对象头（Object Header），其中包含了一些元数据信息，如对象的哈希码、GC 信息、锁信息等。对象头中的锁信息用于支持 <code>synchronized</code> 关键字。</p>
<p>对象头通常包含两部分：</p>
<ul>
<li><strong>Mark Word</strong>：存储对象的运行时数据，如哈希码、GC 标记、锁信息等。</li>
<li><strong>Klass Pointer</strong>：指向对象的类元数据的指针。</li>
</ul>
<h3 id="2-锁的类型"><a href="#2-锁的类型" class="headerlink" title="2. 锁的类型"></a>2. <strong>锁的类型</strong></h3><p><code>synchronized</code> 关键字可以应用于方法或代码块，对应的锁类型如下：</p>
<ul>
<li><strong>对象锁</strong>：当 <code>synchronized</code> 应用于代码块时，锁住的是传入的对象。</li>
<li><strong>类锁</strong>：当 <code>synchronized</code> 应用于静态方法时，锁住的是类的 Class 对象。</li>
</ul>
<h3 id="3-锁的实现"><a href="#3-锁的实现" class="headerlink" title="3. 锁的实现"></a>3. <strong>锁的实现</strong></h3><p><code>synchronized</code> 的实现依赖于 JVM 的锁机制，主要包括以下几种锁状态：</p>
<ul>
<li><strong>无锁状态</strong>：对象没有被任何线程锁定。</li>
<li><strong>偏向锁</strong>：偏向于第一个访问该对象的线程，减少无竞争情况下的锁开销。</li>
<li><strong>轻量级锁</strong>：在没有竞争的情况下，通过 CAS（Compare and Swap）操作实现锁的获取和释放，减少线程阻塞的开销。</li>
<li><strong>重量级锁</strong>：当多个线程竞争锁时，锁会升级为重量级锁，线程会被阻塞并进入操作系统级别的等待队列。</li>
</ul>
<h3 id="4-锁的升级过程"><a href="#4-锁的升级过程" class="headerlink" title="4. 锁的升级过程"></a>4. <strong>锁的升级过程</strong></h3><p><code>synchronized</code> 的锁升级过程如下：</p>
<ol>
<li><strong>偏向锁</strong>：当一个线程第一次访问对象时，JVM 会将对象头中的 Mark Word 设置为偏向锁状态，并将线程 ID 记录在 Mark Word 中。如果后续该线程再次访问对象，可以直接获取锁，无需进行 CAS 操作。</li>
<li><strong>轻量级锁</strong>：当有其他线程尝试获取锁时，偏向锁会升级为轻量级锁。JVM 会在当前线程的栈帧中创建一个锁记录（Lock Record），并将对象的 Mark Word 复制到锁记录中，然后通过 CAS 操作尝试将对象的 Mark Word 替换为指向锁记录的指针。如果 CAS 操作成功，线程获得锁；如果失败，表示有竞争，锁会升级为重量级锁。</li>
<li><strong>重量级锁</strong>：当多个线程竞争锁时，轻量级锁会升级为重量级锁。JVM 会将对象的 Mark Word 替换为指向操作系统互斥量（Mutex）的指针，线程会被阻塞并进入操作系统级别的等待队列。</li>
</ol>
<h3 id="5-锁的释放"><a href="#5-锁的释放" class="headerlink" title="5. 锁的释放"></a>5. <strong>锁的释放</strong></h3><p>当线程执行完同步代码块或方法后，会释放锁。释放锁的过程如下：</p>
<ul>
<li><strong>偏向锁</strong>：如果对象处于偏向锁状态，线程会检查对象的 Mark Word 中的线程 ID 是否与当前线程 ID 一致。如果一致，直接释放锁；如果不一致，偏向锁会撤销，并升级为轻量级锁或重量级锁。</li>
<li><strong>轻量级锁</strong>：线程会通过 CAS 操作将对象的 Mark Word 恢复为原来的状态，并释放锁。</li>
<li><strong>重量级锁</strong>：线程会释放操作系统互斥量，并唤醒等待队列中的其他线程。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>synchronized</code> 关键字的底层原理主要涉及 Java 对象头中的锁信息和 JVM 的锁机制。通过偏向锁、轻量级锁和重量级锁的升级过程，<code>synchronized</code> 实现了线程同步，确保在同一时刻只有一个线程可以访问被保护的代码块或方法。锁的升级和释放过程通过 CAS 操作和操作系统互斥量实现，减少了线程阻塞的开销，提高了性能。</p>
<p>MySQL 事务的底层实现原理涉及多个组件和技术，包括存储引擎、锁机制、日志系统等。以下是 MySQL 事务的底层实现原理的详细解释：</p>
<h3 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1. 存储引擎"></a>1. 存储引擎</h3><p>MySQL 支持多种存储引擎，如 InnoDB、MyISAM、Memory 等。不同的存储引擎对事务的支持程度不同。InnoDB 是 MySQL 默认的存储引擎，支持事务、行级锁和外键约束，适合高并发和事务处理场景。</p>
<h4 id="1-1-InnoDB-存储引擎"><a href="#1-1-InnoDB-存储引擎" class="headerlink" title="1.1 InnoDB 存储引擎"></a>1.1 InnoDB 存储引擎</h4><p>InnoDB 存储引擎是 MySQL 中最常用的事务存储引擎，它提供了以下特性：</p>
<ul>
<li><strong>ACID 特性</strong>：InnoDB 支持原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</li>
<li><strong>行级锁</strong>：InnoDB 支持行级锁，可以提高并发性能。</li>
<li><strong>MVCC（多版本并发控制）</strong>：InnoDB 通过 MVCC 实现事务的隔离性，允许多个事务同时读取同一数据，而不会相互干扰。</li>
<li><strong>外键约束</strong>：InnoDB 支持外键约束，确保数据的完整性。</li>
</ul>
<h3 id="2-锁机制"><a href="#2-锁机制" class="headerlink" title="2. 锁机制"></a>2. 锁机制</h3><p>锁机制是事务隔离性的基础，InnoDB 通过锁机制来控制并发访问。</p>
<h4 id="2-1-锁的类型"><a href="#2-1-锁的类型" class="headerlink" title="2.1 锁的类型"></a>2.1 锁的类型</h4><ul>
<li><strong>共享锁（Shared Lock，S Lock）</strong>：允许多个事务同时读取同一数据，但不允许任何事务修改该数据。</li>
<li><strong>排他锁（Exclusive Lock，X Lock）</strong>：只允许一个事务修改数据，其他事务不能读取或修改该数据。</li>
<li><strong>意向锁（Intention Lock）</strong>：用于指示事务将要对某个数据对象加锁的意图。常见的意向锁包括意向共享锁（IS Lock）和意向排他锁（IX Lock）。</li>
</ul>
<h4 id="2-2-锁的粒度"><a href="#2-2-锁的粒度" class="headerlink" title="2.2 锁的粒度"></a>2.2 锁的粒度</h4><ul>
<li><strong>行级锁</strong>：InnoDB 支持行级锁，可以提高并发性能。</li>
<li><strong>表级锁</strong>：InnoDB 也支持表级锁，但通常只在特定情况下使用，如 DDL 操作。</li>
</ul>
<h3 id="3-日志系统"><a href="#3-日志系统" class="headerlink" title="3. 日志系统"></a>3. 日志系统</h3><p>日志系统是事务持久性的基础，InnoDB 通过日志系统来确保事务的持久性。</p>
<h4 id="3-1-重做日志（Redo-Log）"><a href="#3-1-重做日志（Redo-Log）" class="headerlink" title="3.1 重做日志（Redo Log）"></a>3.1 重做日志（Redo Log）</h4><p>重做日志（Redo Log）用于记录事务对数据页的修改，确保在数据库崩溃后可以恢复未提交的事务。重做日志是物理日志，记录了数据页的修改操作。</p>
<ul>
<li><strong>写入时机</strong>：当事务提交时，InnoDB 会将事务的重做日志写入磁盘。</li>
<li><strong>恢复机制</strong>：在数据库启动时，InnoDB 会根据重做日志恢复未提交的事务。</li>
</ul>
<h4 id="3-2-回滚日志（Undo-Log）"><a href="#3-2-回滚日志（Undo-Log）" class="headerlink" title="3.2 回滚日志（Undo Log）"></a>3.2 回滚日志（Undo Log）</h4><p>回滚日志（Undo Log）用于记录事务对数据页的修改前的状态，确保在事务回滚时可以恢复数据。回滚日志是逻辑日志，记录了数据页的修改前的状态。</p>
<ul>
<li><strong>写入时机</strong>：当事务开始时，InnoDB 会为事务创建回滚日志。</li>
<li><strong>回滚机制</strong>：当事务回滚时，InnoDB 会根据回滚日志恢复数据。</li>
</ul>
<h3 id="4-事务隔离级别"><a href="#4-事务隔离级别" class="headerlink" title="4. 事务隔离级别"></a>4. 事务隔离级别</h3><p>事务隔离级别定义了事务之间的隔离程度，InnoDB 支持以下四种隔离级别：</p>
<ul>
<li><strong>读未提交（Read Uncommitted）</strong>：允许读取未提交的数据，可能导致脏读、不可重复读和幻读。</li>
<li><strong>读已提交（Read Committed）</strong>：允许读取已提交的数据，可以避免脏读，但可能导致不可重复读和幻读。</li>
<li><strong>可重复读（Repeatable Read）</strong>：在同一个事务中，多次读取同一数据的结果一致，可以避免脏读和不可重复读，但可能导致幻读。</li>
<li><strong>串行化（Serializable）</strong>：最高隔离级别，强制事务串行执行，可以避免脏读、不可重复读和幻读。</li>
</ul>
<h3 id="5-MVCC（多版本并发控制）"><a href="#5-MVCC（多版本并发控制）" class="headerlink" title="5. MVCC（多版本并发控制）"></a>5. MVCC（多版本并发控制）</h3><p>MVCC（Multi-Version Concurrency Control）是 InnoDB 实现事务隔离性的核心机制。MVCC 通过为每个数据行维护多个版本，允许多个事务同时读取同一数据，而不会相互干扰。</p>
<h4 id="5-1-实现原理"><a href="#5-1-实现原理" class="headerlink" title="5.1 实现原理"></a>5.1 实现原理</h4><ul>
<li><strong>隐藏字段</strong>：InnoDB 为每个数据行添加了两个隐藏字段：<code>DB_TRX_ID</code>（事务 ID）和 <code>DB_ROLL_PTR</code>（回滚指针）。</li>
<li><strong>版本链</strong>：每个数据行的多个版本通过回滚指针形成一个版本链。</li>
<li><strong>快照读</strong>：在可重复读和读已提交隔离级别下，事务在读取数据时会创建一个快照，读取快照中的数据版本。</li>
<li><strong>当前读</strong>：在读未提交和串行化隔离级别下，事务在读取数据时会读取最新的数据版本。</li>
</ul>
<h3 id="6-事务提交和回滚"><a href="#6-事务提交和回滚" class="headerlink" title="6. 事务提交和回滚"></a>6. 事务提交和回滚</h3><p>事务提交和回滚是事务管理的核心操作，InnoDB 通过日志系统和锁机制来实现事务的提交和回滚。</p>
<h4 id="6-1-事务提交"><a href="#6-1-事务提交" class="headerlink" title="6.1 事务提交"></a>6.1 事务提交</h4><ul>
<li><strong>写重做日志</strong>：当事务提交时，InnoDB 会将事务的重做日志写入磁盘。</li>
<li><strong>释放锁</strong>：当事务提交时，InnoDB 会释放事务持有的锁。</li>
<li><strong>清理回滚日志</strong>：当事务提交时，InnoDB 会清理事务的回滚日志。</li>
</ul>
<h4 id="6-2-事务回滚"><a href="#6-2-事务回滚" class="headerlink" title="6.2 事务回滚"></a>6.2 事务回滚</h4><ul>
<li><strong>读回滚日志</strong>：当事务回滚时，InnoDB 会根据回滚日志恢复数据。</li>
<li><strong>释放锁</strong>：当事务回滚时，InnoDB 会释放事务持有的锁。</li>
<li><strong>清理回滚日志</strong>：当事务回滚时，InnoDB 会清理事务的回滚日志。</li>
</ul>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>MySQL 事务的底层实现原理涉及存储引擎、锁机制、日志系统和 MVCC 等多个组件和技术。InnoDB 存储引擎通过行级锁、重做日志、回滚日志和 MVCC 实现事务的 ACID 特性。事务隔离级别定义了事务之间的隔离程度，MVCC 通过多版本并发控制实现事务的隔离性。事务提交和回滚通过日志系统和锁机制来实现，确保事务的持久性和一致性。</p>
<p>MySQL 索引的底层原理涉及多个组件和技术，包括存储引擎、B+树、哈希索引、全文索引等。以下是 MySQL 索引的底层原理的详细解释：</p>
<h3 id="1-存储引擎-1"><a href="#1-存储引擎-1" class="headerlink" title="1. 存储引擎"></a>1. 存储引擎</h3><p>MySQL 支持多种存储引擎，如 InnoDB、MyISAM、Memory 等。不同的存储引擎对索引的支持程度不同。InnoDB 是 MySQL 默认的存储引擎，支持事务、行级锁和外键约束，适合高并发和事务处理场景。</p>
<h4 id="1-1-InnoDB-存储引擎-1"><a href="#1-1-InnoDB-存储引擎-1" class="headerlink" title="1.1 InnoDB 存储引擎"></a>1.1 InnoDB 存储引擎</h4><p>InnoDB 存储引擎是 MySQL 中最常用的事务存储引擎，它提供了以下特性：</p>
<ul>
<li><strong>ACID 特性</strong>：InnoDB 支持原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</li>
<li><strong>行级锁</strong>：InnoDB 支持行级锁，可以提高并发性能。</li>
<li><strong>MVCC（多版本并发控制）</strong>：InnoDB 通过 MVCC 实现事务的隔离性，允许多个事务同时读取同一数据，而不会相互干扰。</li>
<li><strong>外键约束</strong>：InnoDB 支持外键约束，确保数据的完整性。</li>
</ul>
<h3 id="2-B-树索引"><a href="#2-B-树索引" class="headerlink" title="2. B+树索引"></a>2. B+树索引</h3><p>B+树是 MySQL 中最常用的索引结构，适用于范围查询和排序。B+树是一种平衡的多路搜索树，具有以下特点：</p>
<ul>
<li><strong>平衡性</strong>：B+树的所有叶子节点在同一层，确保查询效率稳定。</li>
<li><strong>多路搜索</strong>：B+树的每个节点可以包含多个键值和指针，使得树的高度较低，查询效率较高。</li>
<li><strong>叶子节点链表</strong>：B+树的叶子节点通过链表连接，适用于范围查询和排序。</li>
</ul>
<h4 id="2-1-B-树的结构"><a href="#2-1-B-树的结构" class="headerlink" title="2.1 B+树的结构"></a>2.1 B+树的结构</h4><p>B+树的结构由多个节点组成，每个节点包含多个键值和指针。B+树的节点分为内部节点和叶子节点：</p>
<ul>
<li><strong>内部节点</strong>：内部节点包含键值和指针，用于指向子节点。内部节点不存储数据，只存储键值和指针。</li>
<li><strong>叶子节点</strong>：叶子节点包含键值和数据指针，用于指向数据行。叶子节点通过链表连接，适用于范围查询和排序。</li>
</ul>
<h4 id="2-2-B-树的查询过程"><a href="#2-2-B-树的查询过程" class="headerlink" title="2.2 B+树的查询过程"></a>2.2 B+树的查询过程</h4><p>B+树的查询过程如下：</p>
<ol>
<li><strong>根节点查询</strong>：从根节点开始，根据查询条件找到对应的子节点。</li>
<li><strong>内部节点查询</strong>：在内部节点中，根据查询条件找到对应的子节点。</li>
<li><strong>叶子节点查询</strong>：在叶子节点中，根据查询条件找到对应的数据行。</li>
</ol>
<h4 id="2-3-B-树的插入和删除"><a href="#2-3-B-树的插入和删除" class="headerlink" title="2.3 B+树的插入和删除"></a>2.3 B+树的插入和删除</h4><p>B+树的插入和删除过程如下：</p>
<ol>
<li><p><strong>插入</strong>：</p>
<ul>
<li>从根节点开始，找到对应的叶子节点。</li>
<li>在叶子节点中插入键值和数据指针。</li>
<li>如果叶子节点已满，进行节点分裂，将部分键值和指针移动到新节点。</li>
<li>更新父节点的指针。</li>
</ul>
</li>
<li><p><strong>删除</strong>：</p>
<ul>
<li>从根节点开始，找到对应的叶子节点。</li>
<li>在叶子节点中删除键值和数据指针。</li>
<li>如果叶子节点过少，进行节点合并，将部分键值和指针移动到相邻节点。</li>
<li>更新父节点的指针。</li>
</ul>
</li>
</ol>
<h3 id="3-哈希索引"><a href="#3-哈希索引" class="headerlink" title="3. 哈希索引"></a>3. 哈希索引</h3><p>哈希索引是一种基于哈希表的索引结构，适用于等值查询。哈希索引具有以下特点：</p>
<ul>
<li><strong>快速查询</strong>：哈希索引通过哈希函数将键值映射到存储位置，查询效率非常高。</li>
<li><strong>不支持范围查询</strong>：哈希索引不支持范围查询和排序。</li>
<li><strong>冲突处理</strong>：哈希索引需要处理哈希冲突，通常使用链表或开放地址法。</li>
</ul>
<h4 id="3-1-哈希索引的结构"><a href="#3-1-哈希索引的结构" class="headerlink" title="3.1 哈希索引的结构"></a>3.1 哈希索引的结构</h4><p>哈希索引的结构由多个桶（Bucket）组成，每个桶包含多个键值和数据指针。哈希索引通过哈希函数将键值映射到对应的桶。</p>
<h4 id="3-2-哈希索引的查询过程"><a href="#3-2-哈希索引的查询过程" class="headerlink" title="3.2 哈希索引的查询过程"></a>3.2 哈希索引的查询过程</h4><p>哈希索引的查询过程如下：</p>
<ol>
<li><strong>哈希计算</strong>：根据查询条件计算哈希值。</li>
<li><strong>桶查询</strong>：根据哈希值找到对应的桶。</li>
<li><strong>键值匹配</strong>：在桶中查找匹配的键值和数据指针。</li>
</ol>
<h4 id="3-3-哈希索引的插入和删除"><a href="#3-3-哈希索引的插入和删除" class="headerlink" title="3.3 哈希索引的插入和删除"></a>3.3 哈希索引的插入和删除</h4><p>哈希索引的插入和删除过程如下：</p>
<ol>
<li><p><strong>插入</strong>：</p>
<ul>
<li>根据键值计算哈希值。</li>
<li>根据哈希值找到对应的桶。</li>
<li>在桶中插入键值和数据指针。</li>
<li>处理哈希冲突。</li>
</ul>
</li>
<li><p><strong>删除</strong>：</p>
<ul>
<li>根据键值计算哈希值。</li>
<li>根据哈希值找到对应的桶。</li>
<li>在桶中删除键值和数据指针。</li>
<li>处理哈希冲突。</li>
</ul>
</li>
</ol>
<h3 id="4-全文索引"><a href="#4-全文索引" class="headerlink" title="4. 全文索引"></a>4. 全文索引</h3><p>全文索引是一种用于全文搜索的索引结构，适用于文本数据的搜索。全文索引具有以下特点：</p>
<ul>
<li><strong>分词</strong>：全文索引需要对文本数据进行分词，将文本数据分解为多个词。</li>
<li><strong>倒排索引</strong>：全文索引使用倒排索引结构，将词映射到文档。</li>
<li><strong>搜索效率</strong>：全文索引的搜索效率较高，适用于大规模文本数据的搜索。</li>
</ul>
<h4 id="4-1-全文索引的结构"><a href="#4-1-全文索引的结构" class="headerlink" title="4.1 全文索引的结构"></a>4.1 全文索引的结构</h4><p>全文索引的结构由多个词和文档列表组成，每个词包含多个文档指针。全文索引通过倒排索引结构将词映射到文档。</p>
<h4 id="4-2-全文索引的查询过程"><a href="#4-2-全文索引的查询过程" class="headerlink" title="4.2 全文索引的查询过程"></a>4.2 全文索引的查询过程</h4><p>全文索引的查询过程如下：</p>
<ol>
<li><strong>分词</strong>：根据查询条件进行分词，将查询条件分解为多个词。</li>
<li><strong>词查询</strong>：根据词找到对应的文档列表。</li>
<li><strong>文档匹配</strong>：在文档列表中查找匹配的文档。</li>
</ol>
<h4 id="4-3-全文索引的插入和删除"><a href="#4-3-全文索引的插入和删除" class="headerlink" title="4.3 全文索引的插入和删除"></a>4.3 全文索引的插入和删除</h4><p>全文索引的插入和删除过程如下：</p>
<ol>
<li><p><strong>插入</strong>：</p>
<ul>
<li>对文本数据进行分词，将文本数据分解为多个词。</li>
<li>根据词找到对应的文档列表。</li>
<li>在文档列表中插入文档指针。</li>
</ul>
</li>
<li><p><strong>删除</strong>：</p>
<ul>
<li>对文本数据进行分词，将文本数据分解为多个词。</li>
<li>根据词找到对应的文档列表。</li>
<li>在文档列表中删除文档指针。</li>
</ul>
</li>
</ol>
<h3 id="5-索引的创建和使用"><a href="#5-索引的创建和使用" class="headerlink" title="5. 索引的创建和使用"></a>5. 索引的创建和使用</h3><h4 id="5-1-创建索引"><a href="#5-1-创建索引" class="headerlink" title="5.1 创建索引"></a>5.1 创建索引</h4><p>在 MySQL 中，可以通过 <code>CREATE INDEX</code> 语句创建索引。例如，在 <code>users</code> 表的 <code>username</code> 列上创建一个 B+树索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_username <span class="keyword">ON</span> users(username);</span><br></pre></td></tr></table></figure>

<h4 id="5-2-使用索引"><a href="#5-2-使用索引" class="headerlink" title="5.2 使用索引"></a>5.2 使用索引</h4><p>当执行查询时，MySQL 会自动选择合适的索引进行数据检索。例如，以下查询会使用 <code>idx_username</code> 索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;john_doe&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-索引的优缺点"><a href="#6-索引的优缺点" class="headerlink" title="6. 索引的优缺点"></a>6. 索引的优缺点</h3><h4 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a>6.1 优点</h4><ul>
<li><strong>提高查询效率</strong>：索引可以显著提高查询效率，减少数据扫描的时间。</li>
<li><strong>加速排序和分组</strong>：索引可以加速 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。</li>
<li><strong>唯一性约束</strong>：通过唯一索引可以确保数据的唯一性。</li>
</ul>
<h4 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a>6.2 缺点</h4><ul>
<li><strong>增加存储空间</strong>：索引需要额外的存储空间，特别是对于大表和高基数列。</li>
<li><strong>降低写操作性能</strong>：每次插入、更新和删除操作都需要更新索引，可能会降低写操作的性能。</li>
<li><strong>索引维护开销</strong>：索引需要定期维护，特别是在数据频繁更新的情况下。</li>
</ul>
<h3 id="7-索引的优化"><a href="#7-索引的优化" class="headerlink" title="7. 索引的优化"></a>7. 索引的优化</h3><p>为了提高索引的效率，可以采用以下优化策略：</p>
<h4 id="7-1-选择合适的列"><a href="#7-1-选择合适的列" class="headerlink" title="7.1 选择合适的列"></a>7.1 选择合适的列</h4><ul>
<li><strong>高基数列</strong>：选择高基数列（即列中不同值的数量较多）创建索引，可以提高查询效率。</li>
<li><strong>频繁查询的列</strong>：选择频繁查询的列创建索引，可以减少数据扫描的时间。</li>
</ul>
<h4 id="7-2-组合索引"><a href="#7-2-组合索引" class="headerlink" title="7.2 组合索引"></a>7.2 组合索引</h4><p>组合索引（Composite Index）是指在多个列上创建的索引。组合索引可以提高多列查询的效率，但需要注意索引列的顺序。例如，在 <code>users</code> 表的 <code>username</code> 和 <code>email</code> 列上创建一个组合索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_username_email <span class="keyword">ON</span> users(username, email);</span><br></pre></td></tr></table></figure>

<h4 id="7-3-覆盖索引"><a href="#7-3-覆盖索引" class="headerlink" title="7.3 覆盖索引"></a>7.3 覆盖索引</h4><p>覆盖索引（Covering Index）是指索引中包含了查询所需的所有列。覆盖索引可以减少数据扫描的时间，提高查询效率。例如，以下查询可以使用 <code>idx_username_email</code> 索引作为覆盖索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username, email <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;john_doe&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-索引维护"><a href="#7-4-索引维护" class="headerlink" title="7.4 索引维护"></a>7.4 索引维护</h4><ul>
<li><strong>定期重建索引</strong>：定期重建索引可以减少索引碎片，提高查询效率。</li>
<li><strong>监控索引使用情况</strong>：通过监控索引的使用情况，可以发现未使用的索引并进行优化。</li>
</ul>
<h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>MySQL 索引的底层原理涉及存储引擎、B+树、哈希索引、全文索引等多个组件和技术。B+树是 MySQL 中最常用的索引结构，适用于范围查询和排序。哈希索引适用于等值查询，全文索引适用于文本数据的搜索。通过创建合适的索引，可以显著提高查询效率，减少数据扫描的时间。索引的创建和使用需要权衡存储空间、写操作性能和索引维护开销。通过选择合适的列、创建组合索引和覆盖索引，以及定期维护索引，可以进一步优化索引的效率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yichen10.github.io/2024/11/05/%E9%9D%A2%E8%AF%954/" data-id="cm33ro1t900033sbz1wrffqiz" data-title="面试4" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试3" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/05/%E9%9D%A2%E8%AF%953/" class="article-date">
  <time class="dt-published" datetime="2024-11-05T01:22:12.000Z" itemprop="datePublished">2024-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/05/%E9%9D%A2%E8%AF%953/">面试3</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Spring Bean的注入方式主要有构造器注入、Setter注入、字段注入和方法注入。每种注入方式都有其优缺点，适用于不同的场景。构造器注入适用于强制依赖和不可变性的场景，Setter注入适用于可选依赖和灵活性的场景，字段注入适用于简洁性的场景，方法注入适用于灵活性和动态配置的场景。理解这些注入方式有助于更好地使用Spring框架，提高代码的可读性和可维护性。</p>
<p>所以第一级缓存Map为： singletonObjects ，第二级缓存： earlySingletonObjects ，第三级缓存： singletonFactories<br>面试官：Spring 是如何解决的呢</p>
<p>　　朋友：通过三级缓存提前暴露对象来解决的</p>
<p>　　面试官：三级缓存里面分别存的什么</p>
<p>　　朋友：一级缓存里存的是成品对象，实例化和初始化都完成了，我们的应用中使用的对象就是一级缓存中的</p>
<p>　　　　二级缓存中存的是半成品，用来解决对象创建过程中的循环依赖问题</p>
<p>　　　　三级缓存中存的是 ObjectFactory&lt;?&gt; 类型的 lambda 表达式，用于处理存在 AOP 时的循环依赖问题</p>
<p>面试官：为什么要用三级缓存来解决循环依赖问题（只用一级缓存行不行，只用二级缓存行不行）</p>
<p>　　朋友：霸点蛮，只用一级缓存也是可以解决的，但是会复杂化整个逻辑</p>
<p>　　　　半成品对象是没法直接使用的（存在 NPE 问题），所以 Spring 需要保证在启动的过程中，所有中间产生的半成品对象最终都会变成成品对象</p>
<p>　　　　如果将半成品对象和成品对象都混在一级缓存中，那么为了区分他们，势必会增加一些而外的标记和逻辑处理，这就会导致对象的创建过程变得复杂化了</p>
<p>　　　　将半成品对象与成品对象分开存放，两级缓存各司其职，能够简化对象的创建过程，更简单、直观</p>
<p>　　　　如果 Spring 不引入 AOP，那么两级缓存就够了，但是作为 Spring 的核心之一，AOP 怎能少得了呢</p>
<p>　　　　所以为了处理 AOP 时的循环依赖，Spring 引入第三级缓存来处理循环依赖时的代理对象的创建</p>
<p>在Spring框架中，Bean的注入方式主要有三种：构造器注入（Constructor Injection）、Setter注入（Setter Injection）和字段注入（Field Injection）。每种注入方式都有其优缺点，适用于不同的场景。以下是详细解释：</p>
<h3 id="1-构造器注入（Constructor-Injection）"><a href="#1-构造器注入（Constructor-Injection）" class="headerlink" title="1. 构造器注入（Constructor Injection）"></a>1. <strong>构造器注入（Constructor Injection）</strong></h3><p>构造器注入是通过构造函数将依赖注入到Bean中。Spring容器会自动调用Bean的构造函数，并将所需的依赖作为参数传递给构造函数。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>强制依赖</strong>：构造器注入强制要求所有依赖在Bean创建时必须提供，确保Bean的完整性。</li>
<li><strong>不可变性</strong>：构造器注入的依赖通常是<code>final</code>的，确保依赖不可变。</li>
<li><strong>测试友好</strong>：构造器注入的Bean易于进行单元测试，可以通过构造函数直接注入Mock对象。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>构造函数参数过多</strong>：如果Bean有很多依赖，构造函数的参数列表可能会变得很长，影响代码的可读性。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EmailService emailService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserRepository userRepository, EmailService emailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">        <span class="built_in">this</span>.emailService = emailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring配置中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userRepository&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;emailService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Setter注入（Setter-Injection）"><a href="#2-Setter注入（Setter-Injection）" class="headerlink" title="2. Setter注入（Setter Injection）"></a>2. <strong>Setter注入（Setter Injection）</strong></h3><p>Setter注入是通过Setter方法将依赖注入到Bean中。Spring容器会自动调用Bean的Setter方法，并将所需的依赖作为参数传递给Setter方法。</p>
<h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>可选依赖</strong>：Setter注入允许依赖是可选的，Bean可以在创建后动态地注入依赖。</li>
<li><strong>灵活性</strong>：Setter注入允许在Bean创建后修改依赖，适用于需要动态配置的场景。</li>
</ul>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>非强制依赖</strong>：Setter注入不强制要求所有依赖在Bean创建时必须提供，可能导致Bean的不完整。</li>
<li><strong>可变性</strong>：Setter注入的依赖通常是可变的，可能引入线程安全问题。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="keyword">private</span> EmailService emailService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserRepository</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmailService</span><span class="params">(EmailService emailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.emailService = emailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring配置中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userRepository&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userRepository&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;emailService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;emailService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-字段注入（Field-Injection）"><a href="#3-字段注入（Field-Injection）" class="headerlink" title="3. 字段注入（Field Injection）"></a>3. <strong>字段注入（Field Injection）</strong></h3><p>字段注入是通过字段直接将依赖注入到Bean中。Spring容器会自动将所需的依赖注入到Bean的字段中。</p>
<h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>简洁性</strong>：字段注入代码简洁，不需要编写构造函数或Setter方法。</li>
</ul>
<h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>非强制依赖</strong>：字段注入不强制要求所有依赖在Bean创建时必须提供，可能导致Bean的不完整。</li>
<li><strong>可变性</strong>：字段注入的依赖通常是可变的，可能引入线程安全问题。</li>
<li><strong>测试不友好</strong>：字段注入的Bean不易于进行单元测试，无法通过构造函数或Setter方法注入Mock对象。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmailService emailService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring配置中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-方法注入（Method-Injection）"><a href="#4-方法注入（Method-Injection）" class="headerlink" title="4. 方法注入（Method Injection）"></a>4. <strong>方法注入（Method Injection）</strong></h3><p>方法注入是通过方法将依赖注入到Bean中。Spring容器会自动调用Bean的方法，并将所需的依赖作为参数传递给方法。</p>
<h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><ul>
<li><strong>灵活性</strong>：方法注入允许在Bean创建后动态地注入依赖，适用于需要动态配置的场景。</li>
</ul>
<h4 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><strong>复杂性</strong>：方法注入的代码相对复杂，需要编写额外的方法。</li>
</ul>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="keyword">private</span> EmailService emailService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(UserRepository userRepository, EmailService emailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">        <span class="built_in">this</span>.emailService = emailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring配置中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring Bean的注入方式主要有构造器注入、Setter注入、字段注入和方法注入。每种注入方式都有其优缺点，适用于不同的场景。构造器注入适用于强制依赖和不可变性的场景，Setter注入适用于可选依赖和灵活性的场景，字段注入适用于简洁性的场景，方法注入适用于灵活性和动态配置的场景。理解这些注入方式有助于更好地使用Spring框架，提高代码的可读性和可维护性。</p>
<p>Nacos（Naming and Configuration Service）是阿里巴巴开源的一个动态服务发现、配置管理和服务管理平台。Nacos在微服务架构中扮演着重要的角色，特别是在服务注册与发现、配置管理、服务健康检查等方面。以下是一些常见的Nacos面试题及其答案：</p>
<h3 id="1-什么是Nacos？它的主要功能是什么？"><a href="#1-什么是Nacos？它的主要功能是什么？" class="headerlink" title="1. 什么是Nacos？它的主要功能是什么？"></a>1. <strong>什么是Nacos？它的主要功能是什么？</strong></h3><p><strong>答案</strong>：Nacos是一个动态服务发现、配置管理和服务管理平台。它的主要功能包括：</p>
<ul>
<li><strong>服务注册与发现</strong>：Nacos支持服务的注册与发现，帮助微服务应用在运行时动态地注册和发现服务实例。</li>
<li><strong>配置管理</strong>：Nacos提供集中式的配置管理，支持动态配置更新，确保应用配置的实时性和一致性。</li>
<li><strong>服务健康检查</strong>：Nacos可以对注册的服务实例进行健康检查，确保只有健康的服务实例被发现和使用。</li>
<li><strong>服务元数据管理</strong>：Nacos支持服务元数据的存储和管理，帮助用户更好地理解和使用服务。</li>
</ul>
<h3 id="2-Nacos与Eureka、Consul、Zookeeper等服务注册中心有什么区别？"><a href="#2-Nacos与Eureka、Consul、Zookeeper等服务注册中心有什么区别？" class="headerlink" title="2. Nacos与Eureka、Consul、Zookeeper等服务注册中心有什么区别？"></a>2. <strong>Nacos与Eureka、Consul、Zookeeper等服务注册中心有什么区别？</strong></h3><p><strong>答案</strong>：Nacos与Eureka、Consul、Zookeeper等服务注册中心的主要区别在于功能和实现方式：</p>
<ul>
<li><strong>功能丰富性</strong>：Nacos不仅支持服务注册与发现，还支持配置管理和服务管理，功能更加丰富。</li>
<li><strong>动态配置</strong>：Nacos支持动态配置更新，而Eureka和Zookeeper不支持。</li>
<li><strong>健康检查</strong>：Nacos内置了健康检查功能，而Eureka和Zookeeper需要额外配置。</li>
<li><strong>易用性</strong>：Nacos提供了更友好的用户界面和API，易于使用和管理。</li>
<li><strong>性能</strong>：Nacos在性能和稳定性方面表现优异，适用于大规模微服务架构。</li>
</ul>
<h3 id="3-Nacos的服务注册与发现是如何实现的？"><a href="#3-Nacos的服务注册与发现是如何实现的？" class="headerlink" title="3. Nacos的服务注册与发现是如何实现的？"></a>3. <strong>Nacos的服务注册与发现是如何实现的？</strong></h3><p><strong>答案</strong>：Nacos的服务注册与发现通过以下步骤实现：</p>
<ol>
<li><strong>服务注册</strong>：服务实例启动时，通过Nacos提供的客户端SDK向Nacos服务器注册服务实例的信息，包括服务名、IP地址、端口等。</li>
<li><strong>服务发现</strong>：客户端通过Nacos提供的API查询服务实例列表，获取可用的服务实例信息。</li>
<li><strong>健康检查</strong>：Nacos服务器定期对注册的服务实例进行健康检查，确保只有健康的服务实例被发现和使用。</li>
<li><strong>负载均衡</strong>：客户端可以根据负载均衡策略选择合适的服务实例进行调用。</li>
</ol>
<h3 id="4-Nacos的配置管理是如何实现的？"><a href="#4-Nacos的配置管理是如何实现的？" class="headerlink" title="4. Nacos的配置管理是如何实现的？"></a>4. <strong>Nacos的配置管理是如何实现的？</strong></h3><p><strong>答案</strong>：Nacos的配置管理通过以下步骤实现：</p>
<ol>
<li><strong>配置发布</strong>：用户通过Nacos提供的管理界面或API发布配置信息，配置信息存储在Nacos服务器中。</li>
<li><strong>配置订阅</strong>：客户端通过Nacos提供的客户端SDK订阅配置信息，Nacos服务器将配置信息推送给客户端。</li>
<li><strong>动态更新</strong>：当配置信息发生变化时，Nacos服务器会实时推送更新后的配置信息给客户端，客户端可以动态更新配置。</li>
<li><strong>配置回滚</strong>：Nacos支持配置的版本管理，用户可以回滚到之前的配置版本。</li>
</ol>
<h3 id="5-Nacos的健康检查机制是什么？"><a href="#5-Nacos的健康检查机制是什么？" class="headerlink" title="5. Nacos的健康检查机制是什么？"></a>5. <strong>Nacos的健康检查机制是什么？</strong></h3><p><strong>答案</strong>：Nacos的健康检查机制包括以下几种方式：</p>
<ul>
<li><strong>TCP检查</strong>：Nacos通过TCP连接检查服务实例的可用性。</li>
<li><strong>HTTP检查</strong>：Nacos通过HTTP请求检查服务实例的可用性。</li>
<li><strong>自定义检查</strong>：用户可以自定义健康检查逻辑，通过Nacos提供的API上报健康状态。</li>
</ul>
<h3 id="6-Nacos的负载均衡策略有哪些？"><a href="#6-Nacos的负载均衡策略有哪些？" class="headerlink" title="6. Nacos的负载均衡策略有哪些？"></a>6. <strong>Nacos的负载均衡策略有哪些？</strong></h3><p><strong>答案</strong>：Nacos支持多种负载均衡策略，包括：</p>
<ul>
<li><strong>随机策略</strong>：随机选择一个服务实例进行调用。</li>
<li><strong>轮询策略</strong>：按顺序轮流选择服务实例进行调用。</li>
<li><strong>加权轮询策略</strong>：根据服务实例的权重进行轮询选择。</li>
<li><strong>加权随机策略</strong>：根据服务实例的权重进行随机选择。</li>
<li><strong>最小连接数策略</strong>：选择当前连接数最少的服务实例进行调用。</li>
</ul>
<h3 id="7-Nacos的配置中心与Spring-Cloud-Config有什么区别？"><a href="#7-Nacos的配置中心与Spring-Cloud-Config有什么区别？" class="headerlink" title="7. Nacos的配置中心与Spring Cloud Config有什么区别？"></a>7. <strong>Nacos的配置中心与Spring Cloud Config有什么区别？</strong></h3><p><strong>答案</strong>：Nacos的配置中心与Spring Cloud Config的主要区别在于功能和实现方式：</p>
<ul>
<li><strong>功能丰富性</strong>：Nacos不仅支持配置管理，还支持服务注册与发现和服务管理，功能更加丰富。</li>
<li><strong>动态配置</strong>：Nacos支持动态配置更新，而Spring Cloud Config需要手动刷新配置。</li>
<li><strong>易用性</strong>：Nacos提供了更友好的用户界面和API，易于使用和管理。</li>
<li><strong>性能</strong>：Nacos在性能和稳定性方面表现优异，适用于大规模微服务架构。</li>
</ul>
<h3 id="8-Nacos的持久化机制是什么？"><a href="#8-Nacos的持久化机制是什么？" class="headerlink" title="8. Nacos的持久化机制是什么？"></a>8. <strong>Nacos的持久化机制是什么？</strong></h3><p><strong>答案</strong>：Nacos的持久化机制包括以下几种方式：</p>
<ul>
<li><strong>内存持久化</strong>：Nacos将服务实例和配置信息存储在内存中，确保高性能。</li>
<li><strong>文件持久化</strong>：Nacos将服务实例和配置信息存储在文件系统中，确保数据持久化。</li>
<li><strong>数据库持久化</strong>：Nacos支持将服务实例和配置信息存储在数据库中，确保数据的高可靠性和一致性。</li>
</ul>
<h3 id="9-Nacos的高可用性是如何实现的？"><a href="#9-Nacos的高可用性是如何实现的？" class="headerlink" title="9. Nacos的高可用性是如何实现的？"></a>9. <strong>Nacos的高可用性是如何实现的？</strong></h3><p><strong>答案</strong>：Nacos的高可用性通过以下方式实现：</p>
<ul>
<li><strong>集群部署</strong>：Nacos支持集群部署，多个Nacos节点组成一个集群，确保服务的高可用性。</li>
<li><strong>数据同步</strong>：Nacos集群中的节点通过数据同步机制保持数据一致性。</li>
<li><strong>负载均衡</strong>：Nacos集群中的节点通过负载均衡机制分担请求压力，确保服务的高性能。</li>
<li><strong>故障转移</strong>：当某个Nacos节点发生故障时，其他节点可以接管服务，确保服务的连续性。</li>
</ul>
<h3 id="10-Nacos的客户端是如何与服务器通信的？"><a href="#10-Nacos的客户端是如何与服务器通信的？" class="headerlink" title="10. Nacos的客户端是如何与服务器通信的？"></a>10. <strong>Nacos的客户端是如何与服务器通信的？</strong></h3><p><strong>答案</strong>：Nacos的客户端与服务器通过以下方式通信：</p>
<ul>
<li><strong>HTTP&#x2F;HTTPS</strong>：客户端通过HTTP&#x2F;HTTPS协议与Nacos服务器进行通信，发送服务注册、服务发现、配置管理等请求。</li>
<li><strong>长轮询</strong>：客户端通过长轮询机制与Nacos服务器进行通信，实时获取配置更新和服务实例变化。</li>
<li><strong>TCP</strong>：客户端通过TCP协议与Nacos服务器进行通信，发送健康检查请求。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Nacos是一个功能强大的动态服务发现、配置管理和服务管理平台，适用于大规模微服务架构。理解Nacos的核心功能和实现机制有助于更好地使用和管理Nacos，提高微服务应用的性能和稳定性。</p>
<p>MyBatis 是一个优秀的持久层框架，支持定制化 SQL、存储过程以及高级映射。MyBatis 提供了两种类型的缓存：一级缓存和二级缓存。一级缓存是默认开启的，作用域是 <code>SqlSession</code>，而二级缓存的作用域是 <code>Mapper</code> 级别，可以跨 <code>SqlSession</code> 共享。</p>
<p>MyBatis 提供了两种级别的缓存机制：一级缓存和二级缓存。这两种缓存机制在作用域、生命周期和使用场景上有所不同。下面详细介绍这两种缓存机制。</p>
<h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>一级缓存是 MyBatis 默认开启的缓存机制，作用域是 <code>SqlSession</code>。每个 <code>SqlSession</code> 都有自己的一级缓存，不同 <code>SqlSession</code> 之间的一级缓存是相互独立的。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><strong>作用域</strong>：<code>SqlSession</code> 级别。</li>
<li><strong>生命周期</strong>：与 <code>SqlSession</code> 的生命周期相同，<code>SqlSession</code> 关闭后，一级缓存也随之失效。</li>
<li><strong>默认开启</strong>：一级缓存是默认开启的，无需额外配置。</li>
<li><strong>缓存更新</strong>：当 <code>SqlSession</code> 执行了 <code>commit</code> 操作（如插入、更新、删除），一级缓存会被清空。</li>
</ol>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li><strong>查询缓存</strong>：当执行查询操作时，MyBatis 首先会检查一级缓存中是否存在相同查询的结果。如果存在，则直接返回缓存中的结果，否则执行数据库查询并将结果存入一级缓存。</li>
<li><strong>缓存清空</strong>：当 <code>SqlSession</code> 执行了 <code>commit</code> 操作，一级缓存会被清空，以保证数据的一致性。</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper.getUserById(<span class="number">1</span>);  <span class="comment">// 第一次查询，从数据库获取</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.getUserById(<span class="number">1</span>);  <span class="comment">// 第二次查询，从一级缓存获取</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存的作用域是 <code>Mapper</code> 级别，可以跨 <code>SqlSession</code> 共享。二级缓存需要手动开启，并且可以通过配置使用不同的缓存实现，如 Ehcache、Redis 等。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li><strong>作用域</strong>：<code>Mapper</code> 级别，即同一个 <code>Mapper</code> 下的所有 <code>SqlSession</code> 共享同一个缓存。</li>
<li><strong>生命周期</strong>：与 <code>Mapper</code> 的生命周期相同，<code>Mapper</code> 被加载时创建，应用程序关闭时销毁。</li>
<li><strong>默认关闭</strong>：二级缓存默认是关闭的，需要手动开启。</li>
<li><strong>缓存更新</strong>：当 <code>SqlSession</code> 执行了 <code>commit</code> 操作，二级缓存会被清空。</li>
</ol>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li><strong>开启二级缓存</strong>：在 <code>Mapper</code> 配置文件中添加 <code>&lt;cache&gt;</code> 标签，或者在 Mapper 接口上使用 <code>@CacheNamespace</code> 注解。</li>
<li><strong>查询缓存</strong>：当执行查询操作时，MyBatis 首先会检查二级缓存中是否存在相同查询的结果。如果存在，则直接返回缓存中的结果，否则检查一级缓存，如果一级缓存中也没有，则执行数据库查询并将结果存入二级缓存。</li>
<li><strong>缓存清空</strong>：当 <code>SqlSession</code> 执行了 <code>commit</code> 操作，二级缓存会被清空，以保证数据的一致性。</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ol>
<li><strong>在 Mapper 配置文件中开启二级缓存</strong>：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 其他 SQL 语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在 Mapper 接口上使用 <code>@CacheNamespace</code> 注解</strong>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 方法定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h3><h4 id="一级缓存配置"><a href="#一级缓存配置" class="headerlink" title="一级缓存配置"></a>一级缓存配置</h4><p>一级缓存是默认开启的，无需额外配置。可以通过 <code>flushCache</code> 属性来控制是否清空缓存：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM users WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="二级缓存配置"><a href="#二级缓存配置" class="headerlink" title="二级缓存配置"></a>二级缓存配置</h4><p>二级缓存需要手动开启，并且可以通过 <code>&lt;cache&gt;</code> 标签进行详细配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">    <span class="attr">eviction</span>=<span class="string">&quot;LRU&quot;</span>  &lt;!<span class="attr">--</span> <span class="attr">缓存淘汰策略</span>：<span class="attr">LRU</span>（<span class="attr">最近最少使用</span>）、<span class="attr">FIFO</span>（<span class="attr">先进先出</span>）<span class="attr">等</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">    flushInterval=&quot;60000&quot;  <span class="comment">&lt;!-- 缓存刷新时间间隔，单位毫秒 --&gt;</span></span><br><span class="line">    size=&quot;512&quot;  <span class="comment">&lt;!-- 缓存大小，单位为对象个数 --&gt;</span></span><br><span class="line">    readOnly=&quot;true&quot;/&gt;  <span class="comment">&lt;!-- 是否只读，true 表示缓存对象为只读，false 表示缓存对象为可读写 --&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="缓存实现"><a href="#缓存实现" class="headerlink" title="缓存实现"></a>缓存实现</h3><p>MyBatis 允许使用自定义的缓存实现。例如，使用 Ehcache 作为二级缓存：</p>
<ol>
<li><strong>引入 Ehcache 依赖</strong>：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>配置 Ehcache</strong>：</li>
</ol>
<p>在 <code>Mapper</code> 配置文件中，使用 <code>type</code> 属性指定 Ehcache 实现类：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>配置 Ehcache 配置文件</strong>：</li>
</ol>
<p>在 <code>ehcache.xml</code> 中配置 Ehcache：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;java.io.tmpdir&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>一级缓存</strong>：默认开启，作用域是 <code>SqlSession</code>，生命周期与 <code>SqlSession</code> 相同。</li>
<li><strong>二级缓存</strong>：需要手动开启，作用域是 <code>Mapper</code>，生命周期与 <code>Mapper</code> 相同，可以跨 <code>SqlSession</code> 共享。</li>
</ul>
<p>通过合理使用一级缓存和二级缓存，可以有效提高 MyBatis 的查询性能。</p>
<p>MyBatis 是一个优秀的持久层框架，广泛应用于 Java 应用中。以下是一些常见的 MyBatis 面试题及其解答，帮助您在面试中更好地展示自己的知识。</p>
<h3 id="1-什么是-MyBatis？"><a href="#1-什么是-MyBatis？" class="headerlink" title="1. 什么是 MyBatis？"></a>1. 什么是 MyBatis？</h3><p><strong>解答</strong>：<br>MyBatis 是一个持久层框架，支持定制化 SQL、存储过程以及高级映射。它简化了数据库操作，允许开发者直接编写 SQL 语句，并将查询结果映射到 Java 对象。MyBatis 提供了灵活的配置选项，适用于各种复杂的数据库操作场景。</p>
<h3 id="2-MyBatis-与-Hibernate-的区别是什么？"><a href="#2-MyBatis-与-Hibernate-的区别是什么？" class="headerlink" title="2. MyBatis 与 Hibernate 的区别是什么？"></a>2. MyBatis 与 Hibernate 的区别是什么？</h3><p><strong>解答</strong>：</p>
<ul>
<li><p><strong>MyBatis</strong>：</p>
<ul>
<li>直接编写 SQL 语句，灵活性高。</li>
<li>需要手动编写 SQL，适合复杂查询和存储过程。</li>
<li>结果集映射到 Java 对象，需要手动配置映射关系。</li>
<li>轻量级，学习曲线较低。</li>
</ul>
</li>
<li><p><strong>Hibernate</strong>：</p>
<ul>
<li>基于 ORM（对象关系映射），自动生成 SQL。</li>
<li>适合简单的 CRUD 操作，减少手动编写 SQL 的工作量。</li>
<li>提供缓存机制，性能优化更方便。</li>
<li>功能强大，但学习曲线较高。</li>
</ul>
</li>
</ul>
<h3 id="3-MyBatis-的核心组件有哪些？"><a href="#3-MyBatis-的核心组件有哪些？" class="headerlink" title="3. MyBatis 的核心组件有哪些？"></a>3. MyBatis 的核心组件有哪些？</h3><p><strong>解答</strong>：</p>
<ul>
<li><strong>SqlSessionFactory</strong>：用于创建 SqlSession 实例，是 MyBatis 的核心接口。</li>
<li><strong>SqlSession</strong>：用于执行 SQL 语句，管理事务，是与数据库交互的主要接口。</li>
<li><strong>Mapper 接口</strong>：定义 SQL 操作的方法，由 MyBatis 动态代理实现。</li>
<li><strong>Mapper 配置文件</strong>：定义 SQL 语句和映射关系。</li>
<li><strong>Configuration</strong>：包含 MyBatis 的所有配置信息。</li>
</ul>
<h3 id="4-如何配置-MyBatis？"><a href="#4-如何配置-MyBatis？" class="headerlink" title="4. 如何配置 MyBatis？"></a>4. 如何配置 MyBatis？</h3><p><strong>解答</strong>：<br>MyBatis 的配置主要包括以下几个步骤：</p>
<ol>
<li><strong>配置数据源</strong>：在 <code>mybatis-config.xml</code> 中配置数据库连接信息。</li>
<li><strong>配置 Mapper</strong>：在 <code>mybatis-config.xml</code> 中注册 Mapper 接口或 XML 文件。</li>
<li><strong>编写 SQL 语句</strong>：在 Mapper XML 文件中编写 SQL 语句。</li>
<li><strong>创建 SqlSessionFactory</strong>：通过 <code>SqlSessionFactoryBuilder</code> 创建 <code>SqlSessionFactory</code> 实例。</li>
<li><strong>获取 SqlSession</strong>：通过 <code>SqlSessionFactory</code> 获取 <code>SqlSession</code> 实例。</li>
</ol>
<h3 id="5-MyBatis-的一级缓存和二级缓存是什么？"><a href="#5-MyBatis-的一级缓存和二级缓存是什么？" class="headerlink" title="5. MyBatis 的一级缓存和二级缓存是什么？"></a>5. MyBatis 的一级缓存和二级缓存是什么？</h3><p><strong>解答</strong>：</p>
<ul>
<li><p><strong>一级缓存</strong>：</p>
<ul>
<li>作用域是 <code>SqlSession</code> 级别，默认开启。</li>
<li>同一个 <code>SqlSession</code> 中的相同查询会使用缓存。</li>
<li><code>SqlSession</code> 关闭后，一级缓存失效。</li>
</ul>
</li>
<li><p><strong>二级缓存</strong>：</p>
<ul>
<li>作用域是 <code>Mapper</code> 级别，需要手动开启。</li>
<li>同一个 <code>Mapper</code> 下的所有 <code>SqlSession</code> 共享同一个缓存。</li>
<li>通过 <code>&lt;cache&gt;</code> 标签或 <code>@CacheNamespace</code> 注解开启。</li>
</ul>
</li>
</ul>
<h3 id="6-如何开启-MyBatis-的二级缓存？"><a href="#6-如何开启-MyBatis-的二级缓存？" class="headerlink" title="6. 如何开启 MyBatis 的二级缓存？"></a>6. 如何开启 MyBatis 的二级缓存？</h3><p><strong>解答</strong>：<br>在 Mapper 配置文件中添加 <code>&lt;cache&gt;</code> 标签：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 其他 SQL 语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者在 Mapper 接口上使用 <code>@CacheNamespace</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">// 方法定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-MyBatis-的动态-SQL-有哪些标签？"><a href="#7-MyBatis-的动态-SQL-有哪些标签？" class="headerlink" title="7. MyBatis 的动态 SQL 有哪些标签？"></a>7. MyBatis 的动态 SQL 有哪些标签？</h3><p><strong>解答</strong>：</p>
<ul>
<li>**<code>&lt;if&gt;</code>**：条件判断，用于动态拼接 SQL 语句。</li>
<li>**<code>&lt;choose&gt;</code>**：类似于 Java 的 switch 语句，用于多条件选择。</li>
<li>**<code>&lt;when&gt;</code>**：配合 <code>&lt;choose&gt;</code> 使用，表示一个条件分支。</li>
<li>**<code>&lt;otherwise&gt;</code>**：配合 <code>&lt;choose&gt;</code> 使用，表示默认分支。</li>
<li>**<code>&lt;where&gt;</code>**：自动处理 SQL 中的 <code>WHERE</code> 子句，避免 <code>WHERE</code> 后的多余 <code>AND</code> 或 <code>OR</code>。</li>
<li>**<code>&lt;set&gt;</code>**：自动处理 SQL 中的 <code>SET</code> 子句，避免 <code>SET</code> 后的多余逗号。</li>
<li>**<code>&lt;foreach&gt;</code>**：用于遍历集合，生成 <code>IN</code> 子句或批量插入。</li>
<li>**<code>&lt;trim&gt;</code>**：自定义 SQL 片段的前后缀。</li>
</ul>
<h3 id="8-MyBatis-的-和-的区别是什么？"><a href="#8-MyBatis-的-和-的区别是什么？" class="headerlink" title="8. MyBatis 的 #{} 和 ${} 的区别是什么？"></a>8. MyBatis 的 <code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的区别是什么？</h3><p><strong>解答</strong>：</p>
<ul>
<li><p>**<code>#&#123;&#125;</code>**：</p>
<ul>
<li>使用预编译语句，防止 SQL 注入。</li>
<li>参数会被自动加上引号，适合用于字符串和日期类型的参数。</li>
</ul>
</li>
<li><p>**<code>$&#123;&#125;</code>**：</p>
<ul>
<li>直接替换参数，不进行预编译，存在 SQL 注入风险。</li>
<li>参数不会自动加上引号，适合用于表名、列名等不需要引号的参数。</li>
</ul>
</li>
</ul>
<h3 id="9-MyBatis-如何处理存储过程？"><a href="#9-MyBatis-如何处理存储过程？" class="headerlink" title="9. MyBatis 如何处理存储过程？"></a>9. MyBatis 如何处理存储过程？</h3><p><strong>解答</strong>：<br>在 Mapper XML 文件中使用 <code>&lt;select&gt;</code> 或 <code>&lt;update&gt;</code> 标签，并设置 <code>statementType=&quot;CALLABLE&quot;</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;callProcedure&quot;</span> <span class="attr">statementType</span>=<span class="string">&quot;CALLABLE&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    &#123;call my_procedure(#&#123;param1, mode=IN&#125;, #&#123;param2, mode=OUT, jdbcType=INTEGER&#125;)&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="10-MyBatis-如何处理分页查询？"><a href="#10-MyBatis-如何处理分页查询？" class="headerlink" title="10. MyBatis 如何处理分页查询？"></a>10. MyBatis 如何处理分页查询？</h3><p><strong>解答</strong>：<br>可以使用 MyBatis 的分页插件，如 <code>PageHelper</code>：</p>
<ol>
<li><strong>引入依赖</strong>：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>配置插件</strong>：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;helperDialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>使用分页</strong>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">List&lt;User&gt; users = userMapper.selectUsers();</span><br><span class="line">PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(users);</span><br></pre></td></tr></table></figure>

<h3 id="11-MyBatis-如何处理事务？"><a href="#11-MyBatis-如何处理事务？" class="headerlink" title="11. MyBatis 如何处理事务？"></a>11. MyBatis 如何处理事务？</h3><p><strong>解答</strong>：<br>MyBatis 通过 <code>SqlSession</code> 管理事务，可以使用以下方法：</p>
<ul>
<li><strong>手动提交</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行 SQL 操作</span></span><br><span class="line">    sqlSession.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    sqlSession.rollback();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>自动提交</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行 SQL 操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-MyBatis-如何处理延迟加载？"><a href="#12-MyBatis-如何处理延迟加载？" class="headerlink" title="12. MyBatis 如何处理延迟加载？"></a>12. MyBatis 如何处理延迟加载？</h3><p><strong>解答</strong>：<br>在 MyBatis 中，可以通过配置 <code>lazyLoadingEnabled</code> 和 <code>aggressiveLazyLoading</code> 来实现延迟加载：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在映射关系中使用 <code>fetchType=&quot;lazy&quot;</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span> <span class="attr">column</span>=<span class="string">&quot;address_id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Address&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>MyBatis 是一个功能强大且灵活的持久层框架，掌握其核心概念和使用技巧对于 Java 开发者来说非常重要。通过以上面试题的解答，您可以更好地理解 MyBatis 的工作原理和常见问题的解决方法，从而在面试中展示自己的专业能力。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yichen10.github.io/2024/11/05/%E9%9D%A2%E8%AF%953/" data-id="cm33ro1t800023sbz9c1j5dmh" data-title="面试3" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/05/%E9%9D%A2%E8%AF%952/" class="article-date">
  <time class="dt-published" datetime="2024-11-05T01:22:07.000Z" itemprop="datePublished">2024-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/05/%E9%9D%A2%E8%AF%952/">面试2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1.HashMap的底层<br>HashMap的底层实现基于（哈希表），通过数组、链表和红黑树的组合，实现了高效的插入、删除和查找操作。哈希函数将键映射到数组的索引，链表和红黑树解决了哈希冲突的问题。扩容机制确保了HashMap在数据量增加时仍然保持高效。理解HashMap的底层实现有助于更好地使用和优化HashMap，提高Java应用的性能。<br>为了提高在链表中查找的效率，当链表长度超过一定阈值（默认为8）时，链表会被转换为红黑树。红黑树是一种自平衡的二叉查找树，查找、插入和删除的时间复杂度为O(log n)。<br>5. 扩容机制（Resizing）<br>当HashMap中的键值对数量超过一定阈值时，会触发扩容操作。扩容会将数组的大小扩大一倍，并将所有键值对重新分配到新的数组中。扩容操作的时间复杂度为O(n)，但由于扩容操作不频繁，整体性能仍然很高。<br>6. 插入操作（put）<br>插入操作的核心逻辑如下：</p>
<p>计算键的哈希值。</p>
<p>根据哈希值计算数组索引。</p>
<p>如果该位置为空，直接插入新节点。</p>
<p>如果该位置不为空，遍历链表（或红黑树），查找是否存在相同的键。</p>
<p>如果存在相同的键，更新值；否则，插入新节点。</p>
<p>如果链表长度超过阈值，将链表转换为红黑树。</p>
<p>检查是否需要扩容。</p>
<p>2.ConcurrentHashMap是怎么保证线程安全的<br>在Java 7及之前的版本中，ConcurrentHashMap使用了分段锁（Segment）机制来实现线程安全。每个Segment相当于一个小的HashMap，拥有自己的锁。多个线程可以同时访问不同的Segment，从而提高并发度。<br>在Java 8及之后的版本中，ConcurrentHashMap放弃了分段锁机制，转而使用CAS（Compare-And-Swap）操作来实现更细粒度的锁。CAS操作是一种乐观锁机制，通过比较内存中的值和预期值，如果相等则更新，否则重试。<br>3. volatile关键字<br>ConcurrentHashMap中的许多变量使用了volatile关键字，确保线程间的可见性。例如，table数组和size变量都使用了volatile关键字。<br>ConcurrentHashMap在Java 8及之后的版本中引入了红黑树来优化链表的查找性能。当链表长度超过一定阈值（默认为8）时，链表会被转换为红黑树。红黑树的查找、插入和删除操作的时间复杂度为O(log n)，提高了并发环境下的性能。<br>6. 读操作的线程安全<br>ConcurrentHashMap的读操作是线程安全的，不需要加锁。读操作通过volatile关键字和CAS操作来确保数据的可见性和一致性。<br>总结<br>ConcurrentHashMap通过分段锁、CAS操作、volatile关键字、红黑树和扩容机制等多种机制来保证线程安全。这些机制使得ConcurrentHashMap在并发环境下具有高效的读写性能，同时确保了数据的一致性和可见性。理解这些机制有助于更好地使用和优化ConcurrentHashMap，提高并发应用的性能。</p>
<p>在JDK 7及之前的版本中，<code>HashMap</code>的扩容机制存在一个潜在的死锁问题。这个问题的根源在于<code>HashMap</code>在扩容时，链表节点的重新分配过程中可能会导致链表形成环形结构，从而引发死锁。以下是详细的原因分析和解决方案：</p>
<h3 id="1-扩容机制"><a href="#1-扩容机制" class="headerlink" title="1. 扩容机制"></a>1. <strong>扩容机制</strong></h3><p>在JDK 7及之前的版本中，<code>HashMap</code>的扩容机制如下：</p>
<ol>
<li><strong>创建新数组</strong>：当<code>HashMap</code>中的元素数量超过阈值时，会创建一个新的数组，其容量是原数组的两倍。</li>
<li><strong>重新分配元素</strong>：遍历原数组中的每个桶（链表），将链表中的每个节点重新分配到新数组中。</li>
</ol>
<h3 id="2-链表节点的重新分配"><a href="#2-链表节点的重新分配" class="headerlink" title="2. 链表节点的重新分配"></a>2. <strong>链表节点的重新分配</strong></h3><p>在重新分配链表节点的过程中，JDK 7及之前的<code>HashMap</code>使用了头插法（Head Insertion），即将原链表中的节点插入到新链表的头部。具体步骤如下：</p>
<ol>
<li><strong>遍历原链表</strong>：从链表头节点开始，依次遍历每个节点。</li>
<li><strong>计算新位置</strong>：根据节点的哈希值和新的数组长度，计算节点在新数组中的位置。</li>
<li><strong>头插法插入</strong>：将节点插入到新数组对应位置的链表头部。</li>
</ol>
<h3 id="3-死锁原因"><a href="#3-死锁原因" class="headerlink" title="3. 死锁原因"></a>3. <strong>死锁原因</strong></h3><p>死锁问题的根源在于头插法可能会导致链表形成环形结构。假设有两个线程A和B同时对同一个<code>HashMap</code>进行扩容操作，并且它们都处理同一个链表。具体过程如下：</p>
<ol>
<li><p><strong>线程A</strong>：</p>
<ul>
<li>遍历链表，处理节点1。</li>
<li>将节点1插入到新数组中的新位置，形成新链表。</li>
<li>线程A被挂起。</li>
</ul>
</li>
<li><p><strong>线程B</strong>：</p>
<ul>
<li>遍历链表，处理节点1。</li>
<li>将节点1插入到新数组中的新位置，形成新链表。</li>
<li>继续处理节点2，将节点2插入到新数组中的新位置。</li>
<li>线程B完成扩容操作。</li>
</ul>
</li>
<li><p><strong>线程A恢复</strong>：</p>
<ul>
<li>继续处理节点2，将节点2插入到新数组中的新位置。</li>
<li>由于线程B已经将节点1和节点2插入到新链表中，线程A在处理节点2时，可能会将节点2插入到节点1的前面，形成环形链表。</li>
</ul>
</li>
</ol>
<h3 id="4-环形链表的形成"><a href="#4-环形链表的形成" class="headerlink" title="4. 环形链表的形成"></a>4. <strong>环形链表的形成</strong></h3><p>假设原链表的结构为：<code>1 -&gt; 2</code>，线程A和线程B的处理过程如下：</p>
<ul>
<li><p><strong>线程A</strong>：</p>
<ul>
<li>处理节点1，插入到新链表：<code>新链表 = 1</code>。</li>
<li>线程A被挂起。</li>
</ul>
</li>
<li><p><strong>线程B</strong>：</p>
<ul>
<li>处理节点1，插入到新链表：<code>新链表 = 1</code>。</li>
<li>处理节点2，插入到新链表：<code>新链表 = 2 -&gt; 1</code>。</li>
<li>线程B完成扩容操作。</li>
</ul>
</li>
<li><p><strong>线程A恢复</strong>：</p>
<ul>
<li>处理节点2，插入到新链表：<code>新链表 = 2 -&gt; 1</code>。</li>
<li>由于线程B已经将节点2插入到节点1的前面，线程A在处理节点2时，会将节点2插入到节点1的前面，形成环形链表：<code>新链表 = 2 -&gt; 1 -&gt; 2</code>。</li>
</ul>
</li>
</ul>
<h3 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5. 解决方案"></a>5. <strong>解决方案</strong></h3><p>为了避免死锁问题，JDK 8及之后的版本对<code>HashMap</code>的扩容机制进行了改进，采用了尾插法（Tail Insertion），即将原链表中的节点插入到新链表的尾部。具体步骤如下：</p>
<ol>
<li><strong>遍历原链表</strong>：从链表头节点开始，依次遍历每个节点。</li>
<li><strong>计算新位置</strong>：根据节点的哈希值和新的数组长度，计算节点在新数组中的位置。</li>
<li><strong>尾插法插入</strong>：将节点插入到新数组对应位置的链表尾部。</li>
</ol>
<p>尾插法避免了链表形成环形结构的问题，从而解决了JDK 7及之前版本中<code>HashMap</code>扩容时的死锁问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JDK 7及之前的<code>HashMap</code>在扩容时使用头插法，可能会导致链表形成环形结构，从而引发死锁问题。JDK 8及之后的版本通过采用尾插法，避免了链表形成环形结构的问题，从而解决了扩容时的死锁问题。理解这些机制有助于更好地使用和优化<code>HashMap</code>，提高Java应用的性能和稳定性。</p>
<h3 id="优化查询：索引是什么，索引底层怎么实现的，用索引要注意什么，数据库很大要怎么办"><a href="#优化查询：索引是什么，索引底层怎么实现的，用索引要注意什么，数据库很大要怎么办" class="headerlink" title="优化查询：索引是什么，索引底层怎么实现的，用索引要注意什么，数据库很大要怎么办"></a>优化查询：索引是什么，索引底层怎么实现的，用索引要注意什么，数据库很大要怎么办</h3><h4 id="1-索引是什么"><a href="#1-索引是什么" class="headerlink" title="1. 索引是什么"></a>1. <strong>索引是什么</strong></h4><p>索引是一种数据结构，用于加速数据库表中数据的检索速度。它类似于书籍的目录，通过索引可以快速定位到特定的数据行，而不需要扫描整个表。索引通常存储在磁盘上，并且是数据库管理系统（DBMS）自动维护的。</p>
<h4 id="2-索引底层怎么实现的"><a href="#2-索引底层怎么实现的" class="headerlink" title="2. 索引底层怎么实现的"></a>2. <strong>索引底层怎么实现的</strong></h4><p>索引的底层实现通常基于以下几种数据结构：</p>
<ul>
<li><p><strong>B树（B-Tree）</strong>：B树是一种平衡的多路搜索树，适用于磁盘存储。B树的每个节点可以有多个子节点，这使得B树在磁盘I&#x2F;O操作中非常高效。B树索引适用于范围查询和点查询。</p>
</li>
<li><p><strong>B+树（B+Tree）</strong>：B+树是B树的变种，它的内部节点只存储键值，不存储数据，所有数据都存储在叶子节点中。叶子节点之间通过指针连接，形成一个有序链表，这使得B+树在范围查询时更加高效。</p>
</li>
<li><p><strong>哈希索引（Hash Index）</strong>：哈希索引通过哈希函数将键值映射到数组中的位置，适用于等值查询。哈希索引不支持范围查询。</p>
</li>
<li><p><strong>位图索引（Bitmap Index）</strong>：位图索引适用于低基数列（即列中不同值的数量较少），它使用位图来表示每个值对应的行。位图索引在处理大量数据时非常高效。</p>
</li>
</ul>
<h4 id="3-用索引要注意什么"><a href="#3-用索引要注意什么" class="headerlink" title="3. 用索引要注意什么"></a>3. <strong>用索引要注意什么</strong></h4><p>使用索引可以显著提高查询性能，但也有一些需要注意的地方：</p>
<ul>
<li><p><strong>选择合适的列</strong>：索引应该建立在经常用于查询条件的列上，如WHERE子句中的列。对于高基数列（即列中不同值的数量较多），索引效果更好。</p>
</li>
<li><p><strong>避免过度索引</strong>：过多的索引会增加写操作（如INSERT、UPDATE、DELETE）的开销，因为每次写操作都需要更新索引。此外，过多的索引会占用更多的磁盘空间。</p>
</li>
<li><p><strong>定期维护索引</strong>：随着数据的插入、更新和删除，索引可能会变得不平衡或碎片化，影响查询性能。定期重建或优化索引可以提高性能。</p>
</li>
<li><p><strong>考虑复合索引</strong>：复合索引是基于多个列的索引。复合索引可以提高多列查询的性能，但要注意索引列的顺序，因为索引的顺序会影响查询优化器的使用。</p>
</li>
<li><p><strong>注意索引的选择性</strong>：索引的选择性是指索引列中不同值的数量与总行数的比率。选择性越高，索引的效果越好。对于低选择性的列，索引的效果可能不明显。</p>
</li>
</ul>
<h4 id="4-数据库很大要怎么办"><a href="#4-数据库很大要怎么办" class="headerlink" title="4. 数据库很大要怎么办"></a>4. <strong>数据库很大要怎么办</strong></h4><p>当数据库变得很大时，可以采取以下几种策略来优化性能：</p>
<ul>
<li><p><strong>分区和分表</strong>：将大表分成多个小表或分区，可以减少单个表的数据量，提高查询性能。分区可以根据时间、地理位置、业务逻辑等进行划分。</p>
</li>
<li><p><strong>垂直分割</strong>：将表中的列分成多个表，每个表只包含相关的列。这样可以减少单个表的宽度，提高查询性能。</p>
</li>
<li><p><strong>水平分割</strong>：将表中的行分成多个表，每个表只包含部分行。水平分割可以根据业务逻辑进行划分，如按用户ID、时间等进行分割。</p>
</li>
<li><p><strong>使用缓存</strong>：使用缓存（如Redis、Memcached）来存储频繁访问的数据，减少数据库的查询压力。</p>
</li>
<li><p><strong>优化查询</strong>：优化查询语句，减少不必要的JOIN操作、子查询和排序操作。使用EXPLAIN命令分析查询计划，找出性能瓶颈。</p>
</li>
<li><p><strong>增加硬件资源</strong>：增加数据库服务器的CPU、内存和磁盘I&#x2F;O资源，可以提高数据库的处理能力。</p>
</li>
<li><p><strong>使用分布式数据库</strong>：对于超大规模的数据库，可以考虑使用分布式数据库（如Hadoop、Cassandra、MongoDB）来分散数据存储和查询压力。</p>
</li>
<li><p><strong>定期归档和清理数据</strong>：定期归档和清理不再使用的数据，可以减少数据库的大小，提高查询性能。</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>索引是优化数据库查询性能的重要工具，通过合理使用索引可以显著提高查询速度。然而，索引的使用也需要注意一些问题，如选择合适的列、避免过度索引、定期维护索引等。当数据库变得很大时，可以采取分区和分表、使用缓存、优化查询、增加硬件资源、使用分布式数据库等策略来优化性能。理解这些机制有助于更好地管理和优化数据库，提高应用的性能和稳定性。</p>
<p>Oracle explain使用；<br>  EXPLAIN PLAN FOR select * from ch_asset_instance a where a.asset_overview_id !&#x3D; 0 ; </p>
<p>  select * from table(dbms_xplan.display);</p>
<p> 分析查询计划（Explain）是优化SQL查询性能的重要工具。通过<code>EXPLAIN</code>命令，可以了解数据库如何执行查询，找出性能瓶颈。以下是详细解释如何使用<code>EXPLAIN</code>命令以及如何解读查询计划。</p>
<h3 id="1-使用EXPLAIN命令"><a href="#1-使用EXPLAIN命令" class="headerlink" title="1. 使用EXPLAIN命令"></a>1. <strong>使用<code>EXPLAIN</code>命令</strong></h3><p>在MySQL中，可以使用<code>EXPLAIN</code>命令来分析查询计划。<code>EXPLAIN</code>命令可以放在<code>SELECT</code>、<code>UPDATE</code>、<code>DELETE</code>和<code>INSERT</code>语句之前。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-查询计划输出字段"><a href="#2-查询计划输出字段" class="headerlink" title="2. 查询计划输出字段"></a>2. <strong>查询计划输出字段</strong></h3><p><code>EXPLAIN</code>命令的输出结果包含多个字段，每个字段提供了关于查询执行的不同信息。以下是一些常见的字段：</p>
<ul>
<li><strong>id</strong>：查询的标识符。如果有多个查询，每个查询都有一个唯一的<code>id</code>。</li>
<li><strong>select_type</strong>：查询的类型，如<code>SIMPLE</code>（简单查询）、<code>PRIMARY</code>（主查询）、<code>SUBQUERY</code>（子查询）等。</li>
<li><strong>table</strong>：查询涉及的表名。</li>
<li><strong>type</strong>：访问类型，表示数据库如何访问表中的数据。常见的访问类型包括：<ul>
<li><code>ALL</code>：全表扫描。</li>
<li><code>index</code>：使用索引扫描全表。</li>
<li><code>range</code>：使用索引进行范围扫描。</li>
<li><code>ref</code>：使用非唯一索引进行等值查询。</li>
<li><code>eq_ref</code>：使用唯一索引进行等值查询。</li>
<li><code>const</code>：使用常量进行查询。</li>
<li><code>system</code>：表中只有一行数据。</li>
</ul>
</li>
<li><strong>possible_keys</strong>：可能使用的索引。</li>
<li><strong>key</strong>：实际使用的索引。</li>
<li><strong>key_len</strong>：使用的索引长度。</li>
<li><strong>ref</strong>：与索引比较的列或常量。</li>
<li><strong>rows</strong>：估计需要扫描的行数。</li>
<li><strong>Extra</strong>：额外的信息，如<code>Using where</code>、<code>Using index</code>、<code>Using temporary</code>、<code>Using filesort</code>等。</li>
</ul>
<h3 id="3-解读查询计划"><a href="#3-解读查询计划" class="headerlink" title="3. 解读查询计划"></a>3. <strong>解读查询计划</strong></h3><p>通过分析<code>EXPLAIN</code>命令的输出结果，可以找出查询的性能瓶颈。以下是一些常见的分析方法：</p>
<h4 id="3-1-访问类型（type）"><a href="#3-1-访问类型（type）" class="headerlink" title="3.1 访问类型（type）"></a>3.1 <strong>访问类型（type）</strong></h4><ul>
<li><strong>ALL</strong>：全表扫描，表示数据库需要扫描整个表来查找数据。全表扫描通常是性能瓶颈，可以通过创建索引来优化。</li>
<li><strong>index</strong>：使用索引扫描全表，虽然使用了索引，但仍然需要扫描整个表。可以通过优化索引或查询条件来减少扫描的行数。</li>
<li><strong>range</strong>：使用索引进行范围扫描，性能较好。</li>
<li><strong>ref</strong>：使用非唯一索引进行等值查询，性能较好。</li>
<li><strong>eq_ref</strong>：使用唯一索引进行等值查询，性能最好。</li>
<li><strong>const</strong>：使用常量进行查询，性能最好。</li>
<li><strong>system</strong>：表中只有一行数据，性能最好。</li>
</ul>
<h4 id="3-2-索引使用情况（key、possible-keys）"><a href="#3-2-索引使用情况（key、possible-keys）" class="headerlink" title="3.2 索引使用情况（key、possible_keys）"></a>3.2 <strong>索引使用情况（key、possible_keys）</strong></h4><ul>
<li><strong>key</strong>：实际使用的索引。如果<code>key</code>为<code>NULL</code>，表示没有使用索引，可能是由于索引缺失或查询条件不匹配索引。</li>
<li><strong>possible_keys</strong>：可能使用的索引。如果<code>possible_keys</code>不为空，但<code>key</code>为<code>NULL</code>，表示查询优化器没有选择使用索引，可能是由于索引选择不当或查询条件不匹配索引。</li>
</ul>
<h4 id="3-3-扫描行数（rows）"><a href="#3-3-扫描行数（rows）" class="headerlink" title="3.3 扫描行数（rows）"></a>3.3 <strong>扫描行数（rows）</strong></h4><ul>
<li><strong>rows</strong>：估计需要扫描的行数。扫描的行数越多，查询性能越差。可以通过创建索引或优化查询条件来减少扫描的行数。</li>
</ul>
<h4 id="3-4-额外信息（Extra）"><a href="#3-4-额外信息（Extra）" class="headerlink" title="3.4 额外信息（Extra）"></a>3.4 <strong>额外信息（Extra）</strong></h4><ul>
<li><strong>Using where</strong>：表示在存储引擎返回行后，MySQL服务器层使用<code>WHERE</code>条件进行过滤。</li>
<li><strong>Using index</strong>：表示查询只使用了索引，没有访问表数据，性能较好。</li>
<li><strong>Using temporary</strong>：表示查询需要创建临时表，性能较差。</li>
<li><strong>Using filesort</strong>：表示查询需要进行文件排序，性能较差。</li>
</ul>
<h3 id="4-示例分析"><a href="#4-示例分析" class="headerlink" title="4. 示例分析"></a>4. <strong>示例分析</strong></h3><p>假设我们有一个用户表<code>users</code>，包含以下字段：<code>id</code>、<code>name</code>、<code>age</code>、<code>email</code>。我们希望查询年龄大于30的用户。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-查询计划输出"><a href="#4-1-查询计划输出" class="headerlink" title="4.1 查询计划输出"></a>4.1 <strong>查询计划输出</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | users | ALL  | NULL          | NULL | NULL    | NULL | 1000 | Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="4-2-分析"><a href="#4-2-分析" class="headerlink" title="4.2 分析"></a>4.2 <strong>分析</strong></h4><ul>
<li><strong>type</strong>：<code>ALL</code>，表示全表扫描，性能较差。</li>
<li><strong>possible_keys</strong>：<code>NULL</code>，表示没有可能使用的索引。</li>
<li><strong>key</strong>：<code>NULL</code>，表示没有实际使用的索引。</li>
<li><strong>rows</strong>：<code>1000</code>，表示需要扫描1000行数据。</li>
<li><strong>Extra</strong>：<code>Using where</code>，表示在存储引擎返回行后，MySQL服务器层使用<code>WHERE</code>条件进行过滤。</li>
</ul>
<h4 id="4-3-优化建议"><a href="#4-3-优化建议" class="headerlink" title="4.3 优化建议"></a>4.3 <strong>优化建议</strong></h4><ul>
<li><strong>创建索引</strong>：在<code>age</code>列上创建索引，减少扫描的行数。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_age <span class="keyword">ON</span> users(age);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>重新分析查询计划</strong>：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优化后的查询计划输出</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | users | range | idx_age       | idx_age | 4       | NULL | 100  | Using where |</span><br><span class="line">+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>分析</strong>：<ul>
<li><strong>type</strong>：<code>range</code>，表示使用索引进行范围扫描，性能较好。</li>
<li><strong>possible_keys</strong>：<code>idx_age</code>，表示可能使用的索引。</li>
<li><strong>key</strong>：<code>idx_age</code>，表示实际使用的索引。</li>
<li><strong>rows</strong>：<code>100</code>，表示需要扫描100行数据，扫描行数显著减少。</li>
<li><strong>Extra</strong>：<code>Using where</code>，表示在存储引擎返回行后，MySQL服务器层使用<code>WHERE</code>条件进行过滤。</li>
</ul>
</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>通过<code>EXPLAIN</code>命令分析查询计划，可以了解数据库如何执行查询，找出性能瓶颈。通过优化访问类型、索引使用情况、扫描行数和额外信息，可以显著提高查询性能。理解这些机制有助于更好地管理和优化数据库，提高应用的性能和稳定性。</p>
<p>Java多线程是面试中常见的高频考点，涉及线程的创建、同步、通信、死锁、线程池等多个方面。以下是一些常见的Java多线程面试题及其答案：</p>
<h3 id="1-什么是线程？"><a href="#1-什么是线程？" class="headerlink" title="1. 什么是线程？"></a>1. <strong>什么是线程？</strong></h3><p><strong>答案</strong>：线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程可以有多个线程，多个线程共享进程的资源。</p>
<h3 id="2-创建线程的方式有哪些？"><a href="#2-创建线程的方式有哪些？" class="headerlink" title="2. 创建线程的方式有哪些？"></a>2. <strong>创建线程的方式有哪些？</strong></h3><p><strong>答案</strong>：Java中创建线程的方式有三种：</p>
<ul>
<li><strong>继承<code>Thread</code>类</strong>：通过继承<code>Thread</code>类并重写<code>run()</code>方法来创建线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实现<code>Runnable</code>接口</strong>：通过实现<code>Runnable</code>接口并重写<code>run()</code>方法来创建线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread is running&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实现<code>Callable</code>接口</strong>：通过实现<code>Callable</code>接口并重写<code>call()</code>方法来创建线程，<code>Callable</code>接口可以返回结果并抛出异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Thread is running&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">System.out.println(future.get());</span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="3-Thread类和Runnable接口的区别是什么？"><a href="#3-Thread类和Runnable接口的区别是什么？" class="headerlink" title="3. Thread类和Runnable接口的区别是什么？"></a>3. <strong><code>Thread</code>类和<code>Runnable</code>接口的区别是什么？</strong></h3><p><strong>答案</strong>：</p>
<ul>
<li><strong><code>Thread</code>类</strong>：继承<code>Thread</code>类并重写<code>run()</code>方法来创建线程。<code>Thread</code>类本身实现了<code>Runnable</code>接口，因此也可以作为<code>Runnable</code>对象传递给<code>Thread</code>构造函数。</li>
<li><strong><code>Runnable</code>接口</strong>：实现<code>Runnable</code>接口并重写<code>run()</code>方法来创建线程。<code>Runnable</code>接口是一个函数式接口，可以使用Lambda表达式来实现。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li><code>Thread</code>类是<code>Runnable</code>接口的实现类，因此继承<code>Thread</code>类的方式更简单，但Java不支持多重继承，因此如果类已经继承了其他类，就无法再继承<code>Thread</code>类。</li>
<li><code>Runnable</code>接口是一个函数式接口，可以使用Lambda表达式来实现，更加灵活。</li>
</ul>
<h3 id="4-什么是线程安全？如何实现线程安全？"><a href="#4-什么是线程安全？如何实现线程安全？" class="headerlink" title="4. 什么是线程安全？如何实现线程安全？"></a>4. <strong>什么是线程安全？如何实现线程安全？</strong></h3><p><strong>答案</strong>：线程安全是指在多线程环境下，多个线程同时访问共享资源时，不会出现数据不一致或错误的情况。实现线程安全的方法有：</p>
<ul>
<li><strong>使用<code>synchronized</code>关键字</strong>：<code>synchronized</code>关键字可以修饰方法或代码块，确保同一时刻只有一个线程可以访问被<code>synchronized</code>保护的代码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用<code>ReentrantLock</code>类</strong>：<code>ReentrantLock</code>类是<code>Lock</code>接口的实现类，提供了更灵活的锁机制。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用<code>volatile</code>关键字</strong>：<code>volatile</code>关键字可以确保变量的可见性，即一个线程对变量的修改对其他线程是立即可见的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用<code>Atomic</code>类</strong>：<code>Atomic</code>类提供了原子操作，确保操作的原子性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-什么是死锁？如何避免死锁？"><a href="#5-什么是死锁？如何避免死锁？" class="headerlink" title="5. 什么是死锁？如何避免死锁？"></a>5. <strong>什么是死锁？如何避免死锁？</strong></h3><p><strong>答案</strong>：死锁是指两个或多个线程互相等待对方释放资源，导致所有线程都无法继续执行的情况。死锁的四个必要条件是：</p>
<ol>
<li><strong>互斥条件</strong>：资源不能被共享，只能被一个线程占用。</li>
<li><strong>请求与保持条件</strong>：线程已经占有一个资源，又请求其他资源。</li>
<li><strong>不可剥夺条件</strong>：资源不能被强制剥夺，只能由占有它的线程释放。</li>
<li><strong>循环等待条件</strong>：多个线程形成一个循环等待资源的链。</li>
</ol>
<p><strong>避免死锁的方法</strong>：</p>
<ul>
<li><strong>破坏互斥条件</strong>：允许资源被多个线程共享，但通常无法实现。</li>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有需要的资源，避免部分申请。</li>
<li><strong>破坏不可剥夺条件</strong>：允许资源被强制剥夺，但通常无法实现。</li>
<li><strong>破坏循环等待条件</strong>：对资源进行排序，确保线程按顺序申请资源。</li>
</ul>
<h3 id="6-什么是线程池？为什么要使用线程池？"><a href="#6-什么是线程池？为什么要使用线程池？" class="headerlink" title="6. 什么是线程池？为什么要使用线程池？"></a>6. <strong>什么是线程池？为什么要使用线程池？</strong></h3><p><strong>答案</strong>：线程池是一组预先创建的线程，用于执行任务。线程池的主要目的是减少线程创建和销毁的开销，提高线程的复用性和系统的性能。</p>
<p><strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>减少线程创建和销毁的开销</strong>：线程池中的线程可以重复使用，避免了频繁创建和销毁线程的开销。</li>
<li><strong>提高系统性能</strong>：线程池可以控制线程的数量，避免系统资源被耗尽。</li>
<li><strong>提高响应速度</strong>：线程池中的线程可以立即执行任务，减少了任务的等待时间。</li>
</ul>
<h3 id="7-Java中有哪些常用的线程池？"><a href="#7-Java中有哪些常用的线程池？" class="headerlink" title="7. Java中有哪些常用的线程池？"></a>7. <strong>Java中有哪些常用的线程池？</strong></h3><p><strong>答案</strong>：Java中常用的线程池有：</p>
<ul>
<li>**<code>FixedThreadPool</code>**：固定大小的线程池，线程数量固定，适用于负载较重的服务器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>CachedThreadPool</code>**：可缓存的线程池，线程数量不固定，适用于执行大量短期异步任务。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>SingleThreadExecutor</code>**：单线程的线程池，适用于需要顺序执行任务的场景。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>ScheduledThreadPool</code>**：定时任务的线程池，适用于需要定时执行任务的场景。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h3 id="8-什么是volatile关键字？它的作用是什么？"><a href="#8-什么是volatile关键字？它的作用是什么？" class="headerlink" title="8. 什么是volatile关键字？它的作用是什么？"></a>8. <strong>什么是<code>volatile</code>关键字？它的作用是什么？</strong></h3><p><strong>答案</strong>：<code>volatile</code>关键字用于修饰变量，确保变量的可见性。当一个变量被<code>volatile</code>修饰时，所有线程都能看到该变量的最新值，即一个线程对变量的修改对其他线程是立即可见的。</p>
<p><strong>作用</strong>：</p>
<ul>
<li><strong>确保可见性</strong>：<code>volatile</code>变量的修改对所有线程都是立即可见的。</li>
<li><strong>禁止指令重排序</strong>：<code>volatile</code>变量的读写操作不会被编译器和处理器重排序。</li>
</ul>
<h3 id="9-什么是synchronized关键字？它的作用是什么？"><a href="#9-什么是synchronized关键字？它的作用是什么？" class="headerlink" title="9. 什么是synchronized关键字？它的作用是什么？"></a>9. <strong>什么是<code>synchronized</code>关键字？它的作用是什么？</strong></h3><p><strong>答案</strong>：<code>synchronized</code>关键字用于修饰方法或代码块，确保同一时刻只有一个线程可以访问被<code>synchronized</code>保护的代码。</p>
<p><strong>作用</strong>：</p>
<ul>
<li><strong>确保线程安全</strong>：<code>synchronized</code>关键字可以防止多个线程同时访问共享资源，避免数据不一致或错误。</li>
<li><strong>确保可见性</strong>：<code>synchronized</code>关键字可以确保线程在进入和退出同步块时，所有变量的修改对其他线程都是立即可见的。</li>
</ul>
<h3 id="10-什么是ReentrantLock？它与synchronized有什么区别？"><a href="#10-什么是ReentrantLock？它与synchronized有什么区别？" class="headerlink" title="10. 什么是ReentrantLock？它与synchronized有什么区别？"></a>10. <strong>什么是<code>ReentrantLock</code>？它与<code>synchronized</code>有什么区别？</strong></h3><p><strong>答案</strong>：<code>ReentrantLock</code>是<code>Lock</code>接口的实现类，提供了更灵活的锁机制。与<code>synchronized</code>关键字相比，<code>ReentrantLock</code>提供了更多的功能和控制。</p>
<p><strong>区别</strong>：</p>
<ul>
<li><strong>灵活性</strong>：<code>ReentrantLock</code>提供了更多的锁控制，如可中断锁、公平锁、非公平锁等。</li>
<li><strong>性能</strong>：在竞争不激烈的情况下，<code>synchronized</code>的性能更好；在竞争激烈的情况下，<code>ReentrantLock</code>的性能更好。</li>
<li><strong>可中断性</strong>：<code>ReentrantLock</code>提供了可中断的锁，线程可以在等待锁的过程中被中断。</li>
<li><strong>公平性</strong>：<code>ReentrantLock</code>可以设置为公平锁，确保等待时间最长的线程优先获得锁。</li>
</ul>
<h3 id="11-什么是ThreadLocal？它的作用是什么？"><a href="#11-什么是ThreadLocal？它的作用是什么？" class="headerlink" title="11. 什么是ThreadLocal？它的作用是什么？"></a>11. <strong>什么是<code>ThreadLocal</code>？它的作用是什么？</strong></h3><p><strong>答案</strong>：<code>ThreadLocal</code>是Java提供的一种线程局部变量机制，每个线程都有自己的<code>ThreadLocal</code>变量副本，互不干扰。</p>
<p><strong>作用</strong>：</p>
<ul>
<li><strong>线程隔离</strong>：<code>ThreadLocal</code>可以确保每个线程都有自己的变量副本，避免线程间的数据共享问题。</li>
<li><strong>线程安全</strong>：<code>ThreadLocal</code>可以避免使用<code>synchronized</code>关键字，提高并发性能。</li>
</ul>
<h3 id="12-什么是CountDownLatch？它的作用是什么？"><a href="#12-什么是CountDownLatch？它的作用是什么？" class="headerlink" title="12. 什么是CountDownLatch？它的作用是什么？"></a>12. <strong>什么是<code>CountDownLatch</code>？它的作用是什么？</strong></h3><p><strong>答案</strong>：<code>CountDownLatch</code>是Java提供的一种同步工具，允许一个或多个线程等待其他线程完成操作。</p>
<p><strong>作用</strong>：</p>
<ul>
<li><strong>等待多个线程完成</strong>：<code>CountDownLatch</code>可以用于等待多个线程完成操作，然后再继续执行。</li>
<li><strong>控制线程执行顺序</strong>：<code>CountDownLatch</code>可以用于控制线程的执行顺序，确保某些线程在其他线程完成之前不会执行。</li>
</ul>
<h3 id="13-什么是CyclicBarrier？它的作用是什么？"><a href="#13-什么是CyclicBarrier？它的作用是什么？" class="headerlink" title="13. 什么是CyclicBarrier？它的作用是什么？"></a>13. <strong>什么是<code>CyclicBarrier</code>？它的作用是什么？</strong></h3><p><strong>答案</strong>：<code>CyclicBarrier</code>是Java提供的一种同步工具，允许一组线程互相等待，直到所有线程都到达一个屏障点。</p>
<p><strong>作用</strong>：</p>
<ul>
<li><strong>线程同步</strong>：<code>CyclicBarrier</code>可以用于多个线程之间的同步，确保所有线程都到达一个屏障点后再继续执行。</li>
<li><strong>循环使用</strong>：<code>CyclicBarrier</code>可以重复使用，每次到达屏障点后，计数器会重置。</li>
</ul>
<h3 id="14-什么是Semaphore？它的作用是什么？"><a href="#14-什么是Semaphore？它的作用是什么？" class="headerlink" title="14. 什么是Semaphore？它的作用是什么？"></a>14. <strong>什么是<code>Semaphore</code>？它的作用是什么？</strong></h3><p><strong>答案</strong>：<code>Semaphore</code>是Java提供的一种同步工具，用于控制同时访问某个资源的线程数量。</p>
<p><strong>作用</strong>：</p>
<ul>
<li><strong>资源控制</strong>：<code>Semaphore</code>可以用于控制同时访问某个资源的线程数量，避免资源被过度使用。</li>
<li><strong>线程同步</strong>：<code>Semaphore</code>可以用于多个线程之间的同步，确保只有一定数量的线程可以同时访问资源。</li>
</ul>
<h3 id="15-什么是Future和FutureTask？它们的作用是什么？"><a href="#15-什么是Future和FutureTask？它们的作用是什么？" class="headerlink" title="15. 什么是Future和FutureTask？它们的作用是什么？"></a>15. <strong>什么是<code>Future</code>和<code>FutureTask</code>？它们的作用是什么？</strong></h3><p><strong>答案</strong>：<code>Future</code>是Java提供的一种异步计算结果的接口，<code>FutureTask</code>是<code>Future</code>接口的实现类。</p>
<p><strong>作用</strong>：</p>
<ul>
<li><strong>异步计算</strong>：<code>Future</code>和<code>FutureTask</code>可以用于异步计算，允许线程在计算结果完成之前继续执行其他任务。</li>
<li><strong>获取计算结果</strong>：<code>Future</code>和<code>FutureTask</code>可以用于获取异步计算的结果，支持阻塞和非阻塞的方式。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>Java多线程是面试中的重要考点，涉及线程的创建、同步、通信、死锁、线程池等多个方面。理解这些概念和机制有助于更好地编写高效、安全的并发程序。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yichen10.github.io/2024/11/05/%E9%9D%A2%E8%AF%952/" data-id="cm33ro1t600013sbzchbacddk" data-title="面试2" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/05/%E9%9D%A2%E8%AF%951/" class="article-date">
  <time class="dt-published" datetime="2024-11-05T01:21:36.000Z" itemprop="datePublished">2024-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/05/%E9%9D%A2%E8%AF%951/">面试1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在Java面试中，<code>java.util.concurrent</code>包是一个非常重要的主题，涉及多线程编程、并发控制、线程池、锁机制等方面。以下是一些常见的<code>java.util.concurrent</code>面试题及其详细解答：</p>
<h3 id="1-什么是java-util-concurrent包？"><a href="#1-什么是java-util-concurrent包？" class="headerlink" title="1. 什么是java.util.concurrent包？"></a>1. <strong>什么是<code>java.util.concurrent</code>包？</strong></h3><ul>
<li><strong>答案</strong>: <code>java.util.concurrent</code>包是Java提供的一个并发编程工具包，包含了一系列用于多线程编程的类和接口。该包提供了线程池、并发集合、锁机制、原子操作、同步工具等，简化了并发编程的复杂性。</li>
</ul>
<h3 id="2-什么是线程池？"><a href="#2-什么是线程池？" class="headerlink" title="2. 什么是线程池？"></a>2. <strong>什么是线程池？</strong></h3><ul>
<li><strong>答案</strong>: 线程池是一种管理线程的机制，通过预先创建一组线程并复用这些线程来执行任务，避免了频繁创建和销毁线程的开销。线程池可以提高系统的性能和稳定性，减少资源消耗。</li>
</ul>
<h3 id="3-Java中有哪些常用的线程池实现？"><a href="#3-Java中有哪些常用的线程池实现？" class="headerlink" title="3. Java中有哪些常用的线程池实现？"></a>3. <strong>Java中有哪些常用的线程池实现？</strong></h3><ul>
<li><strong>答案</strong>: Java中常用的线程池实现包括：<ul>
<li><strong><code>Executors.newFixedThreadPool(int nThreads)</code></strong>: 创建一个固定大小的线程池，线程数量固定，适用于任务量稳定的场景。</li>
<li><strong><code>Executors.newCachedThreadPool()</code></strong>: 创建一个可缓存的线程池，线程数量根据任务量动态调整，适用于任务量不稳定的场景。</li>
<li><strong><code>Executors.newSingleThreadExecutor()</code></strong>: 创建一个单线程的线程池，适用于需要顺序执行任务的场景。</li>
<li><strong><code>Executors.newScheduledThreadPool(int corePoolSize)</code></strong>: 创建一个支持定时和周期性任务的线程池，适用于需要定时执行任务的场景。</li>
</ul>
</li>
</ul>
<h3 id="4-什么是ExecutorService？"><a href="#4-什么是ExecutorService？" class="headerlink" title="4. 什么是ExecutorService？"></a>4. <strong>什么是<code>ExecutorService</code>？</strong></h3><ul>
<li><strong>答案</strong>: <code>ExecutorService</code>是Java提供的一个线程池接口，用于管理和执行任务。<code>ExecutorService</code>提供了提交任务、关闭线程池、获取任务执行结果等方法，简化了线程池的使用。</li>
</ul>
<h3 id="5-什么是Callable和Future？"><a href="#5-什么是Callable和Future？" class="headerlink" title="5. 什么是Callable和Future？"></a>5. <strong>什么是<code>Callable</code>和<code>Future</code>？</strong></h3><ul>
<li><strong>答案</strong>: <code>Callable</code>是一个接口，类似于<code>Runnable</code>，但可以返回结果并抛出异常。<code>Future</code>是一个接口，表示异步计算的结果，可以通过<code>Future</code>获取任务的执行结果、检查任务是否完成、取消任务等。</li>
</ul>
<h3 id="6-如何使用Callable和Future？"><a href="#6-如何使用Callable和Future？" class="headerlink" title="6. 如何使用Callable和Future？"></a>6. <strong>如何使用<code>Callable</code>和<code>Future</code>？</strong></h3><ul>
<li><strong>答案</strong>: 使用<code>Callable</code>和<code>Future</code>的步骤如下：<ol>
<li><strong>实现<code>Callable</code>接口</strong>: 实现<code>Callable</code>接口，重写<code>call</code>方法，返回任务的执行结果。</li>
<li><strong>提交任务</strong>: 使用<code>ExecutorService</code>的<code>submit</code>方法提交<code>Callable</code>任务，返回一个<code>Future</code>对象。</li>
<li><strong>获取结果</strong>: 通过<code>Future</code>对象的<code>get</code>方法获取任务的执行结果。</li>
</ol>
</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; callable = () -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(callable);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Task is running...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-什么是CountDownLatch？"><a href="#7-什么是CountDownLatch？" class="headerlink" title="7. 什么是CountDownLatch？"></a>7. <strong>什么是<code>CountDownLatch</code>？</strong></h3><ul>
<li><strong>答案</strong>: <code>CountDownLatch</code>是一个同步工具类，用于等待一组线程完成操作。<code>CountDownLatch</code>通过一个计数器来实现，初始化时设置计数器的值，线程完成操作后调用<code>countDown</code>方法减少计数器的值，当计数器值为0时，等待的线程被唤醒。</li>
</ul>
<h3 id="8-如何使用CountDownLatch？"><a href="#8-如何使用CountDownLatch？" class="headerlink" title="8. 如何使用CountDownLatch？"></a>8. <strong>如何使用<code>CountDownLatch</code>？</strong></h3><ul>
<li><strong>答案</strong>: 使用<code>CountDownLatch</code>的步骤如下：<ol>
<li><strong>初始化<code>CountDownLatch</code></strong>: 初始化<code>CountDownLatch</code>对象，设置计数器的初始值。</li>
<li><strong>等待线程</strong>: 调用<code>await</code>方法，等待计数器值为0。</li>
<li><strong>完成线程</strong>: 线程完成操作后，调用<code>countDown</code>方法减少计数器的值。</li>
</ol>
</li>
</ul>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; completed&quot;</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;All threads completed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-什么是CyclicBarrier？"><a href="#9-什么是CyclicBarrier？" class="headerlink" title="9. 什么是CyclicBarrier？"></a>9. <strong>什么是<code>CyclicBarrier</code>？</strong></h3><ul>
<li><strong>答案</strong>: <code>CyclicBarrier</code>是一个同步工具类，用于等待一组线程到达某个屏障点。<code>CyclicBarrier</code>通过一个计数器来实现，初始化时设置计数器的值，线程到达屏障点后调用<code>await</code>方法等待其他线程，当所有线程都到达屏障点后，屏障打开，线程继续执行。</li>
</ul>
<h3 id="10-如何使用CyclicBarrier？"><a href="#10-如何使用CyclicBarrier？" class="headerlink" title="10. 如何使用CyclicBarrier？"></a>10. <strong>如何使用<code>CyclicBarrier</code>？</strong></h3><ul>
<li><strong>答案</strong>: 使用<code>CyclicBarrier</code>的步骤如下：<ol>
<li><strong>初始化<code>CyclicBarrier</code></strong>: 初始化<code>CyclicBarrier</code>对象，设置计数器的初始值和屏障打开后的回调任务。</li>
<li><strong>等待线程</strong>: 线程到达屏障点后，调用<code>await</code>方法等待其他线程。</li>
<li><strong>屏障打开</strong>: 当所有线程都到达屏障点后，屏障打开，线程继续执行。</li>
</ol>
</li>
</ul>
<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;All threads reached the barrier&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; is waiting at the barrier&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; passed the barrier&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-什么是Semaphore？"><a href="#11-什么是Semaphore？" class="headerlink" title="11. 什么是Semaphore？"></a>11. <strong>什么是<code>Semaphore</code>？</strong></h3><ul>
<li><strong>答案</strong>: <code>Semaphore</code>是一个同步工具类，用于控制同时访问某个资源的线程数量。<code>Semaphore</code>通过一个计数器来实现，初始化时设置计数器的值，线程访问资源前调用<code>acquire</code>方法获取许可，访问资源后调用<code>release</code>方法释放许可。</li>
</ul>
<h3 id="12-如何使用Semaphore？"><a href="#12-如何使用Semaphore？" class="headerlink" title="12. 如何使用Semaphore？"></a>12. <strong>如何使用<code>Semaphore</code>？</strong></h3><ul>
<li><strong>答案</strong>: 使用<code>Semaphore</code>的步骤如下：<ol>
<li><strong>初始化<code>Semaphore</code></strong>: 初始化<code>Semaphore</code>对象，设置计数器的初始值。</li>
<li><strong>获取许可</strong>: 线程访问资源前，调用<code>acquire</code>方法获取许可。</li>
<li><strong>释放许可</strong>: 线程访问资源后，调用<code>release</code>方法释放许可。</li>
</ol>
</li>
</ul>
<h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the permit&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; released the permit&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-什么是ReentrantLock？"><a href="#13-什么是ReentrantLock？" class="headerlink" title="13. 什么是ReentrantLock？"></a>13. <strong>什么是<code>ReentrantLock</code>？</strong></h3><ul>
<li><strong>答案</strong>: <code>ReentrantLock</code>是一个可重入的互斥锁，类似于<code>synchronized</code>关键字，但提供了更灵活的锁定机制。<code>ReentrantLock</code>支持公平锁和非公平锁，可以中断等待锁的线程，可以尝试获取锁等。</li>
</ul>
<h3 id="14-如何使用ReentrantLock？"><a href="#14-如何使用ReentrantLock？" class="headerlink" title="14. 如何使用ReentrantLock？"></a>14. <strong>如何使用<code>ReentrantLock</code>？</strong></h3><ul>
<li><strong>答案</strong>: 使用<code>ReentrantLock</code>的步骤如下：<ol>
<li><strong>初始化<code>ReentrantLock</code></strong>: 初始化<code>ReentrantLock</code>对象。</li>
<li><strong>获取锁</strong>: 调用<code>lock</code>方法获取锁。</li>
<li><strong>释放锁</strong>: 调用<code>unlock</code>方法释放锁。</li>
</ol>
</li>
</ul>
<h4 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the lock&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; released the lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread 2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-什么是ReadWriteLock？"><a href="#15-什么是ReadWriteLock？" class="headerlink" title="15. 什么是ReadWriteLock？"></a>15. <strong>什么是<code>ReadWriteLock</code>？</strong></h3><ul>
<li><strong>答案</strong>: <code>ReadWriteLock</code>是一个读写锁接口，提供了读锁和写锁两种锁机制。读锁允许多个线程同时读取共享资源，写锁只允许一个线程写入共享资源。<code>ReadWriteLock</code>适用于读多写少的场景，可以提高系统的并发性能。</li>
</ul>
<h3 id="16-如何使用ReadWriteLock？"><a href="#16-如何使用ReadWriteLock？" class="headerlink" title="16. 如何使用ReadWriteLock？"></a>16. <strong>如何使用<code>ReadWriteLock</code>？</strong></h3><ul>
<li><strong>答案</strong>: 使用<code>ReadWriteLock</code>的步骤如下：<ol>
<li><strong>初始化<code>ReadWriteLock</code></strong>: 初始化<code>ReadWriteLock</code>对象。</li>
<li><strong>获取读锁</strong>: 调用<code>readLock</code>方法获取读锁。</li>
<li><strong>获取写锁</strong>: 调用<code>writeLock</code>方法获取写锁。</li>
<li><strong>释放锁</strong>: 调用<code>unlock</code>方法释放锁。</li>
</ol>
</li>
</ul>
<h4 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadWriteLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">readTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the read lock&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.readLock().unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; released the read lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">writeTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the write lock&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.writeLock().unlock();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; released the write lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(readTask, <span class="string">&quot;Read Thread 1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(readTask, <span class="string">&quot;Read Thread 2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(writeTask, <span class="string">&quot;Write Thread&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>java.util.concurrent</code>包提供了丰富的并发编程工具，包括线程池、并发集合、锁机制、原子操作、同步工具等。掌握这些工具的使用方法和原理，有助于在面试中更好地回答相关问题，并在实际开发中进行并发编程和性能优化。</p>
<p>Spring Boot 是一个用于简化Spring应用开发的框架，它基于Spring框架，提供了自动配置、起步依赖、嵌入式服务器等功能。要理解Spring Boot的底层原理，我们需要从以下几个关键点入手：</p>
<h3 id="1-自动配置（Auto-configuration）"><a href="#1-自动配置（Auto-configuration）" class="headerlink" title="1. 自动配置（Auto-configuration）"></a>1. <strong>自动配置（Auto-configuration）</strong></h3><p>Spring Boot的核心特性之一是自动配置。它通过<code>@EnableAutoConfiguration</code>注解来实现。自动配置的原理如下：</p>
<ul>
<li><p><strong>条件注解（Conditional Annotations）</strong>：Spring Boot使用条件注解（如<code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>等）来决定是否应用某个配置。这些条件注解会在Spring容器初始化时进行评估，只有满足条件的配置才会被应用。</p>
</li>
<li><p><strong>META-INF&#x2F;spring.factories</strong>：Spring Boot通过<code>spring.factories</code>文件来加载自动配置类。这些文件通常位于<code>META-INF</code>目录下，包含了需要自动配置的类列表。Spring Boot会根据这些类来决定应用哪些配置。</p>
</li>
<li><p><strong>配置优先级</strong>：自动配置的优先级低于开发者手动配置的Bean。如果开发者手动定义了一个Bean，那么自动配置的Bean会被覆盖。</p>
</li>
</ul>
<h3 id="2-起步依赖（Starter-Dependencies）"><a href="#2-起步依赖（Starter-Dependencies）" class="headerlink" title="2. 起步依赖（Starter Dependencies）"></a>2. <strong>起步依赖（Starter Dependencies）</strong></h3><p>Spring Boot通过起步依赖简化了依赖管理。起步依赖的原理如下：</p>
<ul>
<li><p><strong>依赖传递</strong>：起步依赖本质上是一个Maven或Gradle的依赖管理模块，它包含了某个功能所需的所有依赖。开发者只需要引入一个起步依赖，Spring Boot就会自动管理所有相关的依赖。</p>
</li>
<li><p><strong>版本管理</strong>：Spring Boot通过<code>spring-boot-dependencies</code>模块来管理所有依赖的版本。开发者不需要手动指定每个依赖的版本，Spring Boot会自动选择兼容的版本。</p>
</li>
</ul>
<h3 id="3-嵌入式服务器（Embedded-Server）"><a href="#3-嵌入式服务器（Embedded-Server）" class="headerlink" title="3. 嵌入式服务器（Embedded Server）"></a>3. <strong>嵌入式服务器（Embedded Server）</strong></h3><p>Spring Boot支持嵌入式服务器（如Tomcat、Jetty、Undertow），使得开发者可以轻松地将应用打包成一个可执行的JAR文件。嵌入式服务器的原理如下：</p>
<ul>
<li><p><strong>Servlet容器</strong>：Spring Boot通过<code>spring-boot-starter-web</code>起步依赖引入嵌入式Servlet容器（如Tomcat）。Spring Boot会在应用启动时自动启动嵌入式服务器，并将应用部署到该服务器上。</p>
</li>
<li><p><strong>可执行JAR</strong>：Spring Boot通过<code>spring-boot-maven-plugin</code>或<code>spring-boot-gradle-plugin</code>将应用打包成一个可执行的JAR文件。这个JAR文件包含了应用的所有依赖和嵌入式服务器，可以直接通过<code>java -jar</code>命令运行。</p>
</li>
</ul>
<h3 id="4-SpringApplication"><a href="#4-SpringApplication" class="headerlink" title="4. SpringApplication"></a>4. <strong>SpringApplication</strong></h3><p><code>SpringApplication</code>是Spring Boot应用的入口类，它负责启动Spring应用上下文。<code>SpringApplication</code>的原理如下：</p>
<ul>
<li><p><strong>应用上下文初始化</strong>：<code>SpringApplication</code>会根据应用类型（如Web应用或非Web应用）选择合适的应用上下文（如<code>AnnotationConfigServletWebServerApplicationContext</code>或<code>AnnotationConfigApplicationContext</code>）。</p>
</li>
<li><p><strong>事件机制</strong>：<code>SpringApplication</code>通过事件机制来管理应用的生命周期。在应用启动过程中，会触发一系列事件（如<code>ApplicationStartingEvent</code>、<code>ApplicationEnvironmentPreparedEvent</code>等），开发者可以通过监听这些事件来执行自定义逻辑。</p>
</li>
</ul>
<h3 id="5-外部化配置（Externalized-Configuration）"><a href="#5-外部化配置（Externalized-Configuration）" class="headerlink" title="5. 外部化配置（Externalized Configuration）"></a>5. <strong>外部化配置（Externalized Configuration）</strong></h3><p>Spring Boot支持多种外部化配置方式，如<code>application.properties</code>、<code>application.yml</code>、环境变量、命令行参数等。外部化配置的原理如下：</p>
<ul>
<li><p><strong>配置文件加载</strong>：Spring Boot会自动加载<code>application.properties</code>或<code>application.yml</code>文件中的配置。这些配置文件可以放在多个位置（如classpath根目录、config目录等），Spring Boot会按照优先级顺序加载它们。</p>
</li>
<li><p><strong>配置属性绑定</strong>：Spring Boot通过<code>@ConfigurationProperties</code>注解将配置文件中的属性绑定到Java对象上。开发者可以通过这种方式轻松地将配置文件中的属性映射到Java类中。</p>
</li>
</ul>
<h3 id="6-Spring-Boot-Actuator"><a href="#6-Spring-Boot-Actuator" class="headerlink" title="6. Spring Boot Actuator"></a>6. <strong>Spring Boot Actuator</strong></h3><p>Spring Boot Actuator提供了生产环境下的监控和管理功能。Actuator的原理如下：</p>
<ul>
<li><p><strong>端点（Endpoints）</strong>：Actuator通过HTTP端点暴露应用的监控和管理信息。例如，<code>/health</code>端点可以检查应用的健康状态，<code>/metrics</code>端点可以查看应用的性能指标。</p>
</li>
<li><p><strong>安全管理</strong>：Actuator的端点默认是安全的，开发者可以通过配置来控制哪些端点可以访问，以及访问这些端点所需的权限。</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>Spring Boot的底层原理主要围绕自动配置、起步依赖、嵌入式服务器、应用启动、外部化配置和监控管理等方面展开。通过这些机制，Spring Boot大大简化了Spring应用的开发和部署过程，使得开发者可以更专注于业务逻辑的实现。</p>
<p>JVM（Java虚拟机）优化是提高Java应用程序性能的关键步骤。通过优化JVM，可以减少内存使用、提高垃圾回收效率、减少CPU占用等，从而提升应用的整体性能。以下是一些常见的JVM优化策略和技巧：</p>
<h3 id="1-选择合适的垃圾回收器"><a href="#1-选择合适的垃圾回收器" class="headerlink" title="1. 选择合适的垃圾回收器"></a>1. <strong>选择合适的垃圾回收器</strong></h3><p>JVM提供了多种垃圾回收器，每种回收器都有其适用的场景。选择合适的垃圾回收器可以显著提升性能。</p>
<ul>
<li><strong>Serial GC</strong>：适用于单线程环境和小型应用。</li>
<li><strong>Parallel GC</strong>：适用于多核CPU环境，可以并行处理垃圾回收，适用于吞吐量优先的应用。</li>
<li><strong>CMS（Concurrent Mark Sweep） GC</strong>：适用于低延迟应用，尽量减少STW（Stop-The-World）时间。</li>
<li><strong>G1 GC</strong>：适用于大内存应用，旨在平衡吞吐量和延迟。</li>
<li><strong>ZGC</strong>：适用于超大堆内存应用，具有极低的延迟。</li>
</ul>
<h3 id="2-调整堆内存大小"><a href="#2-调整堆内存大小" class="headerlink" title="2. 调整堆内存大小"></a>2. <strong>调整堆内存大小</strong></h3><p>合理设置堆内存大小可以避免内存溢出和频繁的垃圾回收。</p>
<ul>
<li><strong>-Xms</strong>：设置JVM启动时的初始堆内存大小。</li>
<li><strong>-Xmx</strong>：设置JVM允许使用的最大堆内存大小。</li>
<li><strong>-Xmn</strong>：设置年轻代的大小。</li>
<li><strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong>：设置元空间（Metaspace）的初始大小和最大大小。</li>
</ul>
<h3 id="3-优化垃圾回收参数"><a href="#3-优化垃圾回收参数" class="headerlink" title="3. 优化垃圾回收参数"></a>3. <strong>优化垃圾回收参数</strong></h3><p>通过调整垃圾回收参数，可以进一步优化垃圾回收性能。</p>
<ul>
<li><strong>-XX:SurvivorRatio</strong>：设置Eden区和Survivor区的比例。</li>
<li><strong>-XX:MaxTenuringThreshold</strong>：设置对象在年轻代中存活的最大年龄。</li>
<li><strong>-XX:ParallelGCThreads</strong>：设置并行垃圾回收的线程数。</li>
<li><strong>-XX:ConcGCThreads</strong>：设置并发垃圾回收的线程数。</li>
</ul>
<h3 id="4-使用JIT编译器优化"><a href="#4-使用JIT编译器优化" class="headerlink" title="4. 使用JIT编译器优化"></a>4. <strong>使用JIT编译器优化</strong></h3><p>JVM的JIT（Just-In-Time）编译器可以将热点代码编译成本地代码，从而提高执行效率。</p>
<ul>
<li><strong>-XX:CompileThreshold</strong>：设置方法被编译的调用次数阈值。</li>
<li><strong>-XX:+TieredCompilation</strong>：启用分层编译，结合C1和C2编译器。</li>
<li><strong>-XX:CICompilerCount</strong>：设置JIT编译器的线程数。</li>
</ul>
<h3 id="5-减少内存泄漏"><a href="#5-减少内存泄漏" class="headerlink" title="5. 减少内存泄漏"></a>5. <strong>减少内存泄漏</strong></h3><p>内存泄漏会导致内存使用不断增加，最终导致OutOfMemoryError。</p>
<ul>
<li><strong>使用弱引用（WeakReference）和软引用（SoftReference）</strong>：避免不必要的强引用。</li>
<li><strong>定期检查和清理资源</strong>：确保资源在使用后及时释放。</li>
</ul>
<h3 id="6-使用JVM监控工具"><a href="#6-使用JVM监控工具" class="headerlink" title="6. 使用JVM监控工具"></a>6. <strong>使用JVM监控工具</strong></h3><p>使用JVM监控工具可以帮助你了解JVM的运行状态，从而进行针对性的优化。</p>
<ul>
<li><strong>JVisualVM</strong>：提供JVM的实时监控和分析。</li>
<li><strong>JConsole</strong>：提供JVM的监控和管理功能。</li>
<li><strong>Java Mission Control</strong>：提供高级的JVM监控和分析功能。</li>
<li><strong>GC日志</strong>：通过<code>-XX:+PrintGCDetails</code>和<code>-XX:+PrintGCDateStamps</code>等参数记录GC日志，分析GC行为。</li>
</ul>
<h3 id="7-优化代码"><a href="#7-优化代码" class="headerlink" title="7. 优化代码"></a>7. <strong>优化代码</strong></h3><p>优化代码可以减少JVM的负担，提高执行效率。</p>
<ul>
<li><strong>减少对象创建</strong>：尽量重用对象，避免频繁创建和销毁对象。</li>
<li><strong>使用基本数据类型</strong>：避免不必要的装箱和拆箱操作。</li>
<li><strong>避免使用同步</strong>：尽量减少同步的使用，或者使用更高效的同步机制（如<code>java.util.concurrent</code>包中的工具）。</li>
</ul>
<h3 id="8-调整线程池大小"><a href="#8-调整线程池大小" class="headerlink" title="8. 调整线程池大小"></a>8. <strong>调整线程池大小</strong></h3><p>合理设置线程池大小可以避免线程过多导致的资源竞争和上下文切换开销。</p>
<ul>
<li><strong>-XX:ParallelGCThreads</strong>：设置并行垃圾回收的线程数。</li>
<li><strong>-XX:ConcGCThreads</strong>：设置并发垃圾回收的线程数。</li>
</ul>
<h3 id="9-使用JVM参数优化"><a href="#9-使用JVM参数优化" class="headerlink" title="9. 使用JVM参数优化"></a>9. <strong>使用JVM参数优化</strong></h3><p>通过调整JVM参数，可以进一步优化JVM的性能。</p>
<ul>
<li><strong>-XX:+UseCompressedOops</strong>：启用压缩指针，减少内存占用。</li>
<li><strong>-XX:+UseStringDeduplication</strong>：启用字符串去重，减少字符串对象的内存占用。</li>
<li><strong>-XX:+UseNUMA</strong>：启用NUMA（非统一内存访问）支持，提高多核CPU的性能。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>JVM优化是一个复杂的过程，需要根据具体的应用场景和硬件环境进行调整。通过选择合适的垃圾回收器、调整堆内存大小、优化垃圾回收参数、使用JIT编译器优化、减少内存泄漏、使用JVM监控工具、优化代码和调整线程池大小等策略，可以显著提升Java应用的性能。</p>
<p>JVM（Java虚拟机）是Java平台的核心组件，它负责执行Java字节码。JVM的底层实现涉及多个关键组件和机制，理解这些组件和机制有助于深入理解Java程序的执行过程和性能优化。以下是JVM底层的关键组件和机制：</p>
<h3 id="1-类加载器（Class-Loader）"><a href="#1-类加载器（Class-Loader）" class="headerlink" title="1. 类加载器（Class Loader）"></a>1. <strong>类加载器（Class Loader）</strong></h3><p>类加载器负责将Java类加载到JVM中。JVM的类加载器采用双亲委派模型，确保类的唯一性和安全性。</p>
<ul>
<li><strong>启动类加载器（Bootstrap Class Loader）</strong>：加载Java核心库（如<code>rt.jar</code>）。</li>
<li><strong>扩展类加载器（Extension Class Loader）</strong>：加载Java扩展库（如<code>lib/ext</code>目录下的JAR文件）。</li>
<li><strong>应用类加载器（Application Class Loader）</strong>：加载应用程序的类路径（classpath）中的类。</li>
</ul>
<h3 id="2-运行时数据区（Runtime-Data-Areas）"><a href="#2-运行时数据区（Runtime-Data-Areas）" class="headerlink" title="2. 运行时数据区（Runtime Data Areas）"></a>2. <strong>运行时数据区（Runtime Data Areas）</strong></h3><p>JVM在运行时会创建多个数据区域，用于存储不同类型的数据。</p>
<ul>
<li><strong>方法区（Method Area）</strong>：存储类的结构信息（如类名、父类、方法、字段等）和静态变量。</li>
<li><strong>堆（Heap）</strong>：存储对象实例和数组。堆是垃圾回收的主要区域。</li>
<li><strong>Java栈（Java Stack）</strong>：每个线程都有一个私有的Java栈，用于存储局部变量、操作数栈、方法出口等信息。</li>
<li><strong>本地方法栈（Native Method Stack）</strong>：用于执行本地方法（如C&#x2F;C++代码）。</li>
<li><strong>程序计数器（Program Counter Register）</strong>：存储当前线程执行的字节码指令地址。</li>
</ul>
<h3 id="3-执行引擎（Execution-Engine）"><a href="#3-执行引擎（Execution-Engine）" class="headerlink" title="3. 执行引擎（Execution Engine）"></a>3. <strong>执行引擎（Execution Engine）</strong></h3><p>执行引擎负责执行字节码指令。</p>
<ul>
<li><strong>解释器（Interpreter）</strong>：逐条解释并执行字节码指令。</li>
<li><strong>JIT编译器（Just-In-Time Compiler）</strong>：将热点代码（频繁执行的代码）编译成本地机器码，提高执行效率。</li>
<li><strong>垃圾回收器（Garbage Collector）</strong>：负责回收不再使用的对象，释放内存。</li>
</ul>
<h3 id="4-垃圾回收（Garbage-Collection）"><a href="#4-垃圾回收（Garbage-Collection）" class="headerlink" title="4. 垃圾回收（Garbage Collection）"></a>4. <strong>垃圾回收（Garbage Collection）</strong></h3><p>垃圾回收是JVM的核心功能之一，用于自动管理内存。</p>
<ul>
<li><strong>标记-清除（Mark-Sweep）</strong>：标记不再使用的对象，然后清除这些对象。</li>
<li><strong>复制（Copying）</strong>：将存活的对象复制到另一个区域，然后清除原区域。</li>
<li><strong>标记-整理（Mark-Compact）</strong>：标记不再使用的对象，然后将存活的对象整理到一起，清除剩余空间。</li>
<li><strong>分代收集（Generational Collection）</strong>：将堆分为年轻代和老年代，针对不同代采用不同的回收策略。</li>
</ul>
<h3 id="5-内存模型（Memory-Model）"><a href="#5-内存模型（Memory-Model）" class="headerlink" title="5. 内存模型（Memory Model）"></a>5. <strong>内存模型（Memory Model）</strong></h3><p>JVM内存模型定义了线程如何与内存交互，确保多线程程序的正确性。</p>
<ul>
<li><strong>主内存（Main Memory）</strong>：所有线程共享的内存区域。</li>
<li><strong>工作内存（Working Memory）</strong>：每个线程私有的内存区域，用于存储线程的局部变量和操作数栈。</li>
<li><strong>内存屏障（Memory Barrier）</strong>：确保内存操作的顺序性和可见性。</li>
</ul>
<h3 id="6-JIT编译器（Just-In-Time-Compiler）"><a href="#6-JIT编译器（Just-In-Time-Compiler）" class="headerlink" title="6. JIT编译器（Just-In-Time Compiler）"></a>6. <strong>JIT编译器（Just-In-Time Compiler）</strong></h3><p>JIT编译器将热点代码编译成本地机器码，提高执行效率。</p>
<ul>
<li><strong>C1编译器（Client Compiler）</strong>：适用于客户端应用，编译速度快，优化较少。</li>
<li><strong>C2编译器（Server Compiler）</strong>：适用于服务器端应用，编译速度较慢，但优化更多。</li>
<li><strong>分层编译（Tiered Compilation）</strong>：结合C1和C2编译器，先使用C1编译器快速编译，然后使用C2编译器进行深度优化。</li>
</ul>
<h3 id="7-本地方法接口（Native-Method-Interface-JNI）"><a href="#7-本地方法接口（Native-Method-Interface-JNI）" class="headerlink" title="7. 本地方法接口（Native Method Interface, JNI）"></a>7. <strong>本地方法接口（Native Method Interface, JNI）</strong></h3><p>JNI允许Java代码调用本地方法（如C&#x2F;C++代码），扩展Java的功能。</p>
<ul>
<li><strong>JNI函数</strong>：Java代码通过JNI函数调用本地方法。</li>
<li><strong>本地库（Native Library）</strong>：本地方法的实现通常打包在动态链接库（如<code>.so</code>或<code>.dll</code>文件）中。</li>
</ul>
<h3 id="8-安全管理器（Security-Manager）"><a href="#8-安全管理器（Security-Manager）" class="headerlink" title="8. 安全管理器（Security Manager）"></a>8. <strong>安全管理器（Security Manager）</strong></h3><p>安全管理器用于控制Java应用的访问权限，防止恶意代码执行。</p>
<ul>
<li><strong>安全策略（Security Policy）</strong>：定义应用的访问权限，如文件读写、网络访问等。</li>
<li><strong>安全检查（Security Check）</strong>：在执行敏感操作前进行安全检查，确保操作符合安全策略。</li>
</ul>
<h3 id="9-线程管理（Thread-Management）"><a href="#9-线程管理（Thread-Management）" class="headerlink" title="9. 线程管理（Thread Management）"></a>9. <strong>线程管理（Thread Management）</strong></h3><p>JVM支持多线程编程，线程管理是JVM的重要功能。</p>
<ul>
<li><strong>线程调度（Thread Scheduling）</strong>：操作系统负责线程的调度，JVM通过JNI调用操作系统的线程管理接口。</li>
<li><strong>线程同步（Thread Synchronization）</strong>：通过锁（如<code>synchronized</code>关键字）和条件变量（如<code>java.util.concurrent</code>包中的工具）实现线程同步。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>JVM底层涉及多个关键组件和机制，包括类加载器、运行时数据区、执行引擎、垃圾回收、内存模型、JIT编译器、本地方法接口、安全管理器和线程管理。理解这些组件和机制有助于深入理解Java程序的执行过程和性能优化，从而编写更高效、更安全的Java应用。</p>
<p>元空间（Metaspace）是Java 8及更高版本中引入的一个运行时数据区域，用于存储类的元数据信息。在Java 8之前，类的元数据信息存储在称为“永久代”（PermGen）的内存区域中。由于永久代存在一些限制和问题，Java 8引入了元空间来替代永久代。</p>
<h3 id="元空间的特点"><a href="#元空间的特点" class="headerlink" title="元空间的特点"></a>元空间的特点</h3><ol>
<li><p><strong>动态扩展</strong>：</p>
<ul>
<li>元空间的大小是动态扩展的，不像永久代那样有固定的大小限制。这使得元空间可以根据需要分配更多的内存，避免了永久代中常见的“OutOfMemoryError: PermGen space”问题。</li>
</ul>
</li>
<li><p><strong>本地内存</strong>：</p>
<ul>
<li>元空间使用本地内存（Native Memory），而不是Java堆内存。这意味着元空间的大小不受Java堆大小的限制，可以利用操作系统的本地内存资源。</li>
</ul>
</li>
<li><p><strong>自动管理</strong>：</p>
<ul>
<li>元空间的大小由JVM自动管理，但开发者可以通过JVM参数进行配置。例如，可以使用<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>参数来设置元空间的初始大小和最大大小。</li>
</ul>
</li>
<li><p><strong>垃圾回收</strong>：</p>
<ul>
<li>元空间中的类元数据信息在不再被引用时会被垃圾回收。JVM会定期检查元空间中的类元数据，回收不再使用的类。</li>
</ul>
</li>
</ol>
<h3 id="元空间与永久代的区别"><a href="#元空间与永久代的区别" class="headerlink" title="元空间与永久代的区别"></a>元空间与永久代的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>永久代（PermGen）</th>
<th>元空间（Metaspace）</th>
</tr>
</thead>
<tbody><tr>
<td>内存位置</td>
<td>Java堆内存</td>
<td>本地内存（Native Memory）</td>
</tr>
<tr>
<td>大小限制</td>
<td>固定大小，受限于Java堆大小</td>
<td>动态扩展，不受限于Java堆大小</td>
</tr>
<tr>
<td>内存溢出问题</td>
<td>容易出现“OutOfMemoryError: PermGen space”</td>
<td>较少出现内存溢出问题</td>
</tr>
<tr>
<td>自动管理</td>
<td>需要手动设置大小</td>
<td>自动管理，但可配置</td>
</tr>
<tr>
<td>垃圾回收</td>
<td>回收效率较低</td>
<td>回收效率较高</td>
</tr>
</tbody></table>
<h3 id="元空间的配置参数"><a href="#元空间的配置参数" class="headerlink" title="元空间的配置参数"></a>元空间的配置参数</h3><ul>
<li><strong>-XX:MetaspaceSize</strong>：设置元空间的初始大小。默认值取决于平台，通常较小。</li>
<li><strong>-XX:MaxMetaspaceSize</strong>：设置元空间的最大大小。默认值为无限制，但建议设置一个合理的上限，以避免过度使用本地内存。</li>
<li><strong>-XX:MinMetaspaceFreeRatio</strong>：设置元空间最小空闲比例，当元空间的空闲空间低于此比例时，会触发垃圾回收。</li>
<li><strong>-XX:MaxMetaspaceFreeRatio</strong>：设置元空间最大空闲比例，当元空间的空闲空间高于此比例时，会减少元空间的大小。</li>
</ul>
<h3 id="元空间的使用场景"><a href="#元空间的使用场景" class="headerlink" title="元空间的使用场景"></a>元空间的使用场景</h3><ul>
<li><strong>类加载</strong>：元空间用于存储类的元数据信息，包括类的名称、父类、方法、字段等。</li>
<li><strong>动态代理</strong>：动态代理生成的类元数据信息也会存储在元空间中。</li>
<li><strong>反射</strong>：通过反射生成的类元数据信息也会存储在元空间中。</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>元空间是Java 8及更高版本中用于存储类元数据信息的运行时数据区域，替代了之前的永久代。元空间使用本地内存，具有动态扩展、自动管理、垃圾回收效率高等特点。通过合理配置元空间的大小，可以避免内存溢出问题，提高Java应用的稳定性和性能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yichen10.github.io/2024/11/05/%E9%9D%A2%E8%AF%951/" data-id="cm33ro1t200003sbzh83r32v4" data-title="面试1" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何华为云函数中使用自己的依赖包" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/30/%E5%A6%82%E4%BD%95%E5%8D%8E%E4%B8%BA%E4%BA%91%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%8C%85/" class="article-date">
  <time class="dt-published" datetime="2024-08-30T11:32:32.000Z" itemprop="datePublished">2024-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/30/%E5%A6%82%E4%BD%95%E5%8D%8E%E4%B8%BA%E4%BA%91%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%8C%85/">如何华为云函数中使用自己的依赖包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-创建函数"><a href="#1-创建函数" class="headerlink" title="1. 创建函数"></a>1. 创建函数</h3><p>首先，在华为云控制台创建一个新的函数。</p>
<h3 id="2-准备依赖包"><a href="#2-准备依赖包" class="headerlink" title="2. 准备依赖包"></a>2. 准备依赖包</h3><p>将你的依赖包和函数代码打包成一个ZIP文件。确保你的依赖包和函数代码在同一个目录下。</p>
<p>例如，假设你的项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_function/</span><br><span class="line">├── __init__.py</span><br><span class="line">├── my_function.py</span><br><span class="line">└── requirements.txt</span><br></pre></td></tr></table></figure>

<p>在<code>my_function</code>目录下，运行以下命令来安装依赖包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt -t .</span><br></pre></td></tr></table></figure>

<p>这将把所有依赖包安装到当前目录（<code>my_function</code>）中。</p>
<h3 id="3-打包项目"><a href="#3-打包项目" class="headerlink" title="3. 打包项目"></a>3. 打包项目</h3><p>将整个目录打包成一个ZIP文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r my_function.zip .</span><br></pre></td></tr></table></figure>

<h3 id="4-上传ZIP文件"><a href="#4-上传ZIP文件" class="headerlink" title="4. 上传ZIP文件"></a>4. 上传ZIP文件</h3><p>在华为云函数控制台中，找到你创建的函数，进入“代码”页面，选择“上传ZIP文件”，然后上传你刚刚创建的<code>my_function.zip</code>文件。</p>
<h3 id="5-配置函数"><a href="#5-配置函数" class="headerlink" title="5. 配置函数"></a>5. 配置函数</h3><p>确保你的函数入口配置正确。例如，如果你的函数入口是<code>my_function.handler</code>，则在函数配置中设置入口为<code>my_function.handler</code>。</p>
<h3 id="6-测试函数"><a href="#6-测试函数" class="headerlink" title="6. 测试函数"></a>6. 测试函数</h3><p>保存并测试你的函数，确保一切正常运行。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>假设你的<code>my_function.py</code>文件内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">event, context</span>):</span><br><span class="line">    response = requests.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> response.text</span><br></pre></td></tr></table></figure>

<p><code>requirements.txt</code>文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requests==2.25.1</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上步骤，你可以在华为云函数中使用自己的依赖包。关键步骤包括准备依赖包、打包项目、上传ZIP文件和配置函数入口。这样，你的函数就可以使用自定义的依赖包了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yichen10.github.io/2024/08/30/%E5%A6%82%E4%BD%95%E5%8D%8E%E4%B8%BA%E4%BA%91%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%8C%85/" data-id="cm0gmyb7b00006gbz8z4ad7yi" data-title="如何华为云函数中使用自己的依赖包" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Jira常用API" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/19/Jira%E5%B8%B8%E7%94%A8API/" class="article-date">
  <time class="dt-published" datetime="2024-08-19T07:04:13.000Z" itemprop="datePublished">2024-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/19/Jira%E5%B8%B8%E7%94%A8API/">Jira常用API</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在我们的日常开发过程中，可以使用jira的api来对jira进行操作，比如创建issue，更新issue，更新issue状态，查询issue列表等。下面我来列举常用的api。</p>
<h3 id="创建Issue"><a href="#创建Issue" class="headerlink" title="创建Issue"></a>创建Issue</h3><p>创建issue使得我们可以使用代码创建issue，api地址为：&#x2F;rest&#x2F;api&#x2F;2&#x2F;issue&#x2F;XXXX，使用Post方法，参数格式为：<br>{<br>    “fields”: {<br>        “project”: {<br>            “id”: “10000”<br>        },<br>        “summary”: “创建问题概况”,<br>        “issuetype”: {<br>            “id”: “10003”<br>        },<br>        “priority”: {<br>            “id”: “3”<br>        },<br>      “customfield_10000”: {<br>            “value”: “abcd”<br>        },<br>        “description”: “创建问题描述”<br>    }<br>}</p>
<h3 id="修改issue"><a href="#修改issue" class="headerlink" title="修改issue"></a>修改issue</h3><p>修改issue的api地址为：&#x2F;rest&#x2F;api&#x2F;2&#x2F;issue&#x2F;issueKey，使用Put方法，将需要添加或者修改的参数放在json中：<br>{<br>    “fields” : {<br>        “description”: “Description111”,<br>        “customfield_10000”: {<br>            “value”: “ad”<br>        }<br>    }<br>}</p>
<h3 id="获取issue详情："><a href="#获取issue详情：" class="headerlink" title="获取issue详情："></a>获取issue详情：</h3><p>获取issue详情的地址为：&#x2F;rest&#x2F;api&#x2F;2&#x2F;issue&#x2F;issueKey，使用get方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yichen10.github.io/2024/08/19/Jira%E5%B8%B8%E7%94%A8API/" data-id="cm00nn9wz0000mcbzeqjmg40d" data-title="Jira常用API" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/19/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-08-19T06:46:10.150Z" itemprop="datePublished">2024-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/19/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yichen10.github.io/2024/08/19/hello-world/" data-id="cm00n9ton00004sbz1k1wc2ds" data-title="Hello World" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%955-spring%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/">面试5-spring基础相关</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%954/">面试4</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%953/">面试3</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%952/">面试2</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%951/">面试1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 yichen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>