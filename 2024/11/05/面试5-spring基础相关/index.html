<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面试5-spring基础相关 | 一尘的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Spring 框架中的 Bean 生命周期是指 Bean 从创建到销毁的整个过程。Spring 提供了丰富的回调机制和接口，使得开发者可以在 Bean 生命周期的不同阶段执行自定义的初始化和销毁逻辑。 Spring Bean 生命周期概述Spring Bean 的生命周期可以分为以下几个主要阶段：  实例化（Instantiation） 属性赋值（Populate Properties） 初始化（">
<meta property="og:type" content="article">
<meta property="og:title" content="面试5-spring基础相关">
<meta property="og:url" content="https://yichen10.github.io/2024/11/05/%E9%9D%A2%E8%AF%955-spring%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="一尘的个人博客">
<meta property="og:description" content="Spring 框架中的 Bean 生命周期是指 Bean 从创建到销毁的整个过程。Spring 提供了丰富的回调机制和接口，使得开发者可以在 Bean 生命周期的不同阶段执行自定义的初始化和销毁逻辑。 Spring Bean 生命周期概述Spring Bean 的生命周期可以分为以下几个主要阶段：  实例化（Instantiation） 属性赋值（Populate Properties） 初始化（">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-11-05T02:02:54.000Z">
<meta property="article:modified_time" content="2024-11-05T02:03:13.079Z">
<meta property="article:author" content="yichen">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="一尘的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">一尘的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yichen10.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-面试5-spring基础相关" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/05/%E9%9D%A2%E8%AF%955-spring%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/" class="article-date">
  <time class="dt-published" datetime="2024-11-05T02:02:54.000Z" itemprop="datePublished">2024-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面试5-spring基础相关
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Spring 框架中的 Bean 生命周期是指 Bean 从创建到销毁的整个过程。Spring 提供了丰富的回调机制和接口，使得开发者可以在 Bean 生命周期的不同阶段执行自定义的初始化和销毁逻辑。</p>
<h3 id="Spring-Bean-生命周期概述"><a href="#Spring-Bean-生命周期概述" class="headerlink" title="Spring Bean 生命周期概述"></a>Spring Bean 生命周期概述</h3><p>Spring Bean 的生命周期可以分为以下几个主要阶段：</p>
<ol>
<li><strong>实例化（Instantiation）</strong></li>
<li><strong>属性赋值（Populate Properties）</strong></li>
<li><strong>初始化（Initialization）</strong></li>
<li><strong>使用（In Use）</strong></li>
<li><strong>销毁（Destruction）</strong></li>
</ol>
<h3 id="详细的生命周期步骤"><a href="#详细的生命周期步骤" class="headerlink" title="详细的生命周期步骤"></a>详细的生命周期步骤</h3><ol>
<li><p><strong>实例化（Instantiation）</strong></p>
<ul>
<li>Spring 容器根据配置创建 Bean 的实例。</li>
</ul>
</li>
<li><p><strong>属性赋值（Populate Properties）</strong></p>
<ul>
<li>Spring 容器将配置文件或注解中定义的属性值注入到 Bean 实例中。</li>
</ul>
</li>
<li><p><strong>BeanNameAware 接口</strong></p>
<ul>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，Spring 容器会调用 <code>setBeanName(String name)</code> 方法，传递 Bean 的名称。</li>
</ul>
</li>
<li><p><strong>BeanFactoryAware 接口</strong></p>
<ul>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，Spring 容器会调用 <code>setBeanFactory(BeanFactory beanFactory)</code> 方法，传递 BeanFactory 实例。</li>
</ul>
</li>
<li><p><strong>ApplicationContextAware 接口</strong></p>
<ul>
<li>如果 Bean 实现了 <code>ApplicationContextAware</code> 接口，Spring 容器会调用 <code>setApplicationContext(ApplicationContext applicationContext)</code> 方法，传递 ApplicationContext 实例。</li>
</ul>
</li>
<li><p><strong>BeanPostProcessor 前置处理</strong></p>
<ul>
<li>Spring 容器调用所有 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization(Object bean, String beanName)</code> 方法，对 Bean 进行前置处理。</li>
</ul>
</li>
<li><p><strong>InitializingBean 接口</strong></p>
<ul>
<li>如果 Bean 实现了 <code>InitializingBean</code> 接口，Spring 容器会调用 <code>afterPropertiesSet()</code> 方法。</li>
</ul>
</li>
<li><p><strong>自定义初始化方法</strong></p>
<ul>
<li>Spring 容器调用配置中指定的自定义初始化方法（如 <code>@PostConstruct</code> 注解或 XML 配置中的 <code>init-method</code>）。</li>
</ul>
</li>
<li><p><strong>BeanPostProcessor 后置处理</strong></p>
<ul>
<li>Spring 容器调用所有 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization(Object bean, String beanName)</code> 方法，对 Bean 进行后置处理。</li>
</ul>
</li>
<li><p><strong>使用（In Use）</strong></p>
<ul>
<li>Bean 处于可用状态，可以被应用程序使用。</li>
</ul>
</li>
<li><p><strong>DisposableBean 接口</strong></p>
<ul>
<li>如果 Bean 实现了 <code>DisposableBean</code> 接口，Spring 容器会在 Bean 销毁时调用 <code>destroy()</code> 方法。</li>
</ul>
</li>
<li><p><strong>自定义销毁方法</strong></p>
<ul>
<li>Spring 容器调用配置中指定的自定义销毁方法（如 <code>@PreDestroy</code> 注解或 XML 配置中的 <code>destroy-method</code>）。</li>
</ul>
</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个示例，展示了如何在 Spring Bean 生命周期的不同阶段执行自定义逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanNameAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.DisposableBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean, DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1. Bean 实例化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanName = name;</span><br><span class="line">        System.out.println(<span class="string">&quot;2. BeanNameAware: Bean 名称 - &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">        System.out.println(<span class="string">&quot;3. ApplicationContextAware: ApplicationContext 设置&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postConstruct</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5. @PostConstruct: 自定义初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4. InitializingBean: afterPropertiesSet 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customInitMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;6. 自定义初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useBean</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;7. 使用 Bean&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;8. @PreDestroy: 自定义销毁方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;9. DisposableBean: destroy 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customDestroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;10. 自定义销毁方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在 Spring 配置文件中，可以指定自定义的初始化和销毁方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.MyBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;customInitMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;customDestroyMethod&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring Bean 生命周期提供了丰富的回调机制，使得开发者可以在 Bean 的不同阶段执行自定义逻辑。通过实现特定的接口或使用注解，可以轻松地在 Bean 的初始化和销毁阶段添加自定义行为。</p>
<p>Spring 框架提供了强大的事务管理功能，使得开发者可以轻松地在应用程序中实现事务管理。Spring 事务管理的核心是基于 AOP（面向切面编程）和事务管理器（TransactionManager）。Spring 支持多种事务管理方式，包括声明式事务管理和编程式事务管理。</p>
<h3 id="Spring-事务管理的核心组件"><a href="#Spring-事务管理的核心组件" class="headerlink" title="Spring 事务管理的核心组件"></a>Spring 事务管理的核心组件</h3><ol>
<li><p><strong>PlatformTransactionManager</strong>:</p>
<ul>
<li>这是 Spring 事务管理的核心接口，定义了事务管理的基本操作，如 <code>getTransaction()</code>、<code>commit()</code> 和 <code>rollback()</code>。</li>
<li>Spring 提供了多种实现类，如 <code>DataSourceTransactionManager</code>、<code>JtaTransactionManager</code> 等，用于不同的数据访问技术。</li>
</ul>
</li>
<li><p><strong>TransactionDefinition</strong>:</p>
<ul>
<li>定义了事务的属性，如隔离级别、传播行为、超时时间和只读标志。</li>
</ul>
</li>
<li><p><strong>TransactionStatus</strong>:</p>
<ul>
<li>表示事务的当前状态，提供了一些方法来检查事务的状态和执行回滚操作。</li>
</ul>
</li>
</ol>
<h3 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h3><p>声明式事务管理是 Spring 中最常用的事务管理方式，它允许开发者通过配置来定义事务边界，而不需要编写大量的样板代码。</p>
<h4 id="使用-XML-配置"><a href="#使用-XML-配置" class="headerlink" title="使用 XML 配置"></a>使用 XML 配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;serviceOperation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.example.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;serviceOperation&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用注解配置"><a href="#使用注解配置" class="headerlink" title="使用注解配置"></a>使用注解配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Spring 配置类中启用事务管理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 其他配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><p>编程式事务管理允许开发者通过编写代码来显式地控制事务的开始、提交和回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.PlatformTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.DefaultTransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">TransactionDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(def);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userRepository.save(user);</span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p>Spring 支持多种事务传播行为，定义了事务方法调用时的事务行为：</p>
<ul>
<li><strong>REQUIRED</strong>: 如果当前存在事务，则加入该事务；否则创建一个新事务。</li>
<li><strong>REQUIRES_NEW</strong>: 创建一个新事务，如果当前存在事务，则挂起当前事务。</li>
<li><strong>SUPPORTS</strong>: 如果当前存在事务，则加入该事务；否则以非事务方式执行。</li>
<li><strong>NOT_SUPPORTED</strong>: 以非事务方式执行操作，如果当前存在事务，则挂起当前事务。</li>
<li><strong>MANDATORY</strong>: 如果当前存在事务，则加入</li>
</ul>
<p>AOP（Aspect-Oriented Programming，面向切面编程）和 OOP（Object-Oriented Programming，面向对象编程）是两种不同的编程范式，它们各自解决不同的问题，但在实际应用中常常结合使用，以提高代码的可维护性和可扩展性。</p>
<h3 id="1-面向对象编程（OOP）"><a href="#1-面向对象编程（OOP）" class="headerlink" title="1. 面向对象编程（OOP）"></a>1. 面向对象编程（OOP）</h3><p><strong>OOP 的核心概念</strong>：</p>
<ul>
<li><strong>封装（Encapsulation）</strong>：将数据和操作数据的方法封装在一起，隐藏内部实现细节，只暴露必要的接口。</li>
<li><strong>继承（Inheritance）</strong>：通过继承机制，子类可以继承父类的属性和方法，从而实现代码复用。</li>
<li><strong>多态（Polymorphism）</strong>：允许不同类的对象对同一消息做出响应，通过方法重载和方法重写实现。</li>
<li><strong>抽象（Abstraction）</strong>：通过抽象类和接口定义对象的行为，隐藏具体实现细节。</li>
</ul>
<p><strong>OOP 的优势</strong>：</p>
<ul>
<li><strong>代码复用</strong>：通过继承和组合实现代码复用。</li>
<li><strong>模块化</strong>：将系统分解为多个对象，每个对象负责特定的功能。</li>
<li><strong>可维护性</strong>：通过封装和抽象，降低代码的耦合度，提高可维护性。</li>
</ul>
<p><strong>OOP 的局限性</strong>：</p>
<ul>
<li><strong>横切关注点</strong>：OOP 难以处理横切关注点（cross-cutting concerns），如日志记录、事务管理、安全性检查等。这些关注点在多个模块中重复出现，导致代码冗余和难以维护。</li>
</ul>
<h3 id="2-面向切面编程（AOP）"><a href="#2-面向切面编程（AOP）" class="headerlink" title="2. 面向切面编程（AOP）"></a>2. 面向切面编程（AOP）</h3><p><strong>AOP 的核心概念</strong>：</p>
<ul>
<li><strong>切面（Aspect）</strong>：一个模块化的横切关注点，通常包含通知（Advice）和切点（Pointcut）。</li>
<li><strong>通知（Advice）</strong>：在特定的连接点（Join Point）执行的代码，例如在方法执行前、执行后、抛出异常时执行的代码。</li>
<li><strong>切点（Pointcut）</strong>：定义了通知应该在哪些连接点上执行。</li>
<li><strong>连接点（Join Point）</strong>：程序执行过程中的一个点，例如方法调用、异常抛出等。</li>
<li><strong>目标对象（Target Object）</strong>：被代理的对象，即应用了切面的对象。</li>
<li><strong>代理（Proxy）</strong>：在目标对象上应用了切面逻辑后生成的对象。</li>
</ul>
<p><strong>AOP 的优势</strong>：</p>
<ul>
<li><strong>分离关注点</strong>：将横切关注点与业务逻辑分离，提高代码的模块化和可维护性。</li>
<li><strong>减少代码冗余</strong>：横切关注点的代码只需编写一次，然后在多个地方应用。</li>
<li><strong>提高可扩展性</strong>：通过切面，可以在不修改原有代码的情况下，增加新的功能。</li>
</ul>
<p><strong>AOP 的局限性</strong>：</p>
<ul>
<li><strong>复杂性</strong>：AOP 引入了新的概念和机制，增加了代码的复杂性。</li>
<li><strong>性能开销</strong>：AOP 代理机制可能会引入一定的性能开销。</li>
</ul>
<h3 id="3-AOP-与-OOP-的关系"><a href="#3-AOP-与-OOP-的关系" class="headerlink" title="3. AOP 与 OOP 的关系"></a>3. AOP 与 OOP 的关系</h3><ul>
<li><strong>互补关系</strong>：AOP 和 OOP 是互补的编程范式。OOP 提供了对象和类的抽象，而 AOP 提供了横切关注点的抽象。</li>
<li><strong>结合使用</strong>：在实际应用中，AOP 和 OOP 常常结合使用。通过 AOP，可以将横切关注点从业务逻辑中分离出来，而通过 OOP，可以实现对象和类的抽象。</li>
</ul>
<h3 id="4-示例说明"><a href="#4-示例说明" class="headerlink" title="4. 示例说明"></a>4. 示例说明</h3><p>假设我们有一个服务类 <code>UserService</code>，我们希望在它的方法执行前后记录日志。</p>
<h4 id="1-使用-OOP-实现"><a href="#1-使用-OOP-实现" class="headerlink" title="1. 使用 OOP 实现"></a>1. 使用 OOP 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        logBefore(<span class="string">&quot;createUser&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating user: &quot;</span> + username);</span><br><span class="line">        logAfter(<span class="string">&quot;createUser&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before &quot;</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After &quot;</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，日志记录代码与业务逻辑代码混合在一起，导致代码冗余和难以维护。</p>
<h4 id="2-使用-AOP-实现"><a href="#2-使用-AOP-实现" class="headerlink" title="2. 使用 AOP 实现"></a>2. 使用 AOP 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method execution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.example.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After method execution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Spring 配置中，我们需要启用 AOP 和组件扫描：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过依赖注入，我们可以获取 <code>UserService</code> 的代理对象并使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        userService.createUser(<span class="string">&quot;JohnDoe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before method execution</span><br><span class="line">Creating user: JohnDoe</span><br><span class="line">After method execution</span><br></pre></td></tr></table></figure>

<p>在这个例子中，日志记录代码被分离到 <code>LoggingAspect</code> 中，与业务逻辑代码解耦，提高了代码的可维护性和可扩展性。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>面向对象编程（OOP）</strong>：通过封装、继承、多态和抽象，实现对象和类的抽象，提高代码的模块化和可维护性。</li>
<li><strong>面向切面编程（AOP）</strong>：通过切面、通知、切点和连接点，实现横切关注点的抽象，提高代码的模块化和可维护性。</li>
<li><strong>互补关系</strong>：AOP 和 OOP 是互补的编程范式，在实际应用中常常结合使用，以提高代码的可维护性和可扩展性。</li>
</ul>
<p>通过理解和应用这两种编程范式，可以显著提高代码的可维护性和可扩展性。</p>
<p>Spring AOP（Aspect-Oriented Programming）和依赖注入（Dependency Injection，简称DI）是Spring框架中的两个核心概念，它们分别解决了不同的问题，但在实际应用中常常结合使用。</p>
<h3 id="1-Spring-AOP（面向切面编程）"><a href="#1-Spring-AOP（面向切面编程）" class="headerlink" title="1. Spring AOP（面向切面编程）"></a>1. Spring AOP（面向切面编程）</h3><p><strong>AOP的概念</strong>：<br>AOP是一种编程范式，旨在将横切关注点（cross-cutting concerns）与业务逻辑分离。横切关注点是指那些在多个模块中重复出现的代码，例如日志记录、事务管理、安全性检查等。通过AOP，可以将这些横切关注点从业务逻辑中分离出来，使得代码更加模块化和易于维护。</p>
<p><strong>AOP的核心概念</strong>：</p>
<ul>
<li><strong>切面（Aspect）</strong>：一个模块化的横切关注点，通常包含通知（Advice）和切点（Pointcut）。</li>
<li><strong>通知（Advice）</strong>：在特定的连接点（Join Point）执行的代码，例如在方法执行前、执行后、抛出异常时执行的代码。</li>
<li><strong>切点（Pointcut）</strong>：定义了通知应该在哪些连接点上执行。</li>
<li><strong>连接点（Join Point）</strong>：程序执行过程中的一个点，例如方法调用、异常抛出等。</li>
<li><strong>目标对象（Target Object）</strong>：被代理的对象，即应用了切面的对象。</li>
<li><strong>代理（Proxy）</strong>：在目标对象上应用了切面逻辑后生成的对象。</li>
</ul>
<p><strong>AOP的实现方式</strong>：</p>
<ul>
<li><strong>基于JDK动态代理</strong>：适用于实现了接口的目标对象。</li>
<li><strong>基于CGLIB代理</strong>：适用于没有实现接口的目标对象。</li>
</ul>
<p><strong>AOP的应用场景</strong>：</p>
<ul>
<li>日志记录</li>
<li>事务管理</li>
<li>安全性检查</li>
<li>性能监控</li>
</ul>
<h3 id="2-依赖注入（Dependency-Injection）"><a href="#2-依赖注入（Dependency-Injection）" class="headerlink" title="2. 依赖注入（Dependency Injection）"></a>2. 依赖注入（Dependency Injection）</h3><p><strong>DI的概念</strong>：<br>依赖注入是一种设计模式，用于实现控制反转（Inversion of Control，简称IoC）。通过依赖注入，对象的依赖关系由外部容器（如Spring容器）在运行时动态注入，而不是由对象自己创建或查找依赖。</p>
<p><strong>DI的核心概念</strong>：</p>
<ul>
<li><strong>依赖（Dependency）</strong>：一个对象所依赖的其他对象。</li>
<li><strong>注入（Injection）</strong>：将依赖对象传递给目标对象的过程。</li>
<li><strong>容器（Container）</strong>：负责管理对象的生命周期和依赖关系的容器，如Spring的ApplicationContext。</li>
</ul>
<p><strong>DI的实现方式</strong>：</p>
<ul>
<li><strong>构造器注入（Constructor Injection）</strong>：通过构造函数注入依赖。</li>
<li><strong>Setter注入（Setter Injection）</strong>：通过Setter方法注入依赖。</li>
<li><strong>字段注入（Field Injection）</strong>：通过反射直接注入字段（不推荐，因为破坏了封装性）。</li>
</ul>
<p><strong>DI的优势</strong>：</p>
<ul>
<li>降低耦合度：对象不需要知道如何创建或查找依赖。</li>
<li>提高可测试性：依赖可以被替换为测试替身（如Mock对象）。</li>
<li>代码复用：相同的依赖可以在多个对象之间共享。</li>
</ul>
<h3 id="3-Spring-AOP与依赖注入的关系"><a href="#3-Spring-AOP与依赖注入的关系" class="headerlink" title="3. Spring AOP与依赖注入的关系"></a>3. Spring AOP与依赖注入的关系</h3><ul>
<li><strong>结合使用</strong>：Spring AOP和依赖注入通常结合使用。依赖注入负责管理对象的生命周期和依赖关系，而AOP则负责处理横切关注点。</li>
<li><strong>AOP代理</strong>：在Spring中，AOP代理通常是通过依赖注入创建的。Spring容器会自动为应用了切面的目标对象创建代理，并将代理对象注入到需要的地方。</li>
<li><strong>事务管理</strong>：Spring的事务管理就是一个典型的AOP应用。通过AOP，Spring可以在方法调用前后自动开启、提交或回滚事务，而无需在业务逻辑中显式处理事务。</li>
</ul>
<h3 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4. 示例代码"></a>4. 示例代码</h3><p>假设我们有一个服务类<code>UserService</code>，我们希望在它的方法执行前后记录日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creating user: &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过AOP来实现日志记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method execution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.example.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After method execution&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Spring配置中，我们需要启用AOP和组件扫描：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过依赖注入，我们可以获取<code>UserService</code>的代理对象并使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        userService.createUser(<span class="string">&quot;JohnDoe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before method execution</span><br><span class="line">Creating user: JohnDoe</span><br><span class="line">After method execution</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>UserService</code>的<code>createUser</code>方法被AOP代理拦截，并在方法执行前后记录了日志。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>Spring AOP</strong>：用于处理横切关注点，将这些关注点与业务逻辑分离。</li>
<li><strong>依赖注入</strong>：用于管理对象的依赖关系，降低耦合度。</li>
<li><strong>结合使用</strong>：在Spring中，AOP和DI通常结合使用，AOP代理通过DI创建并注入到需要的地方。</li>
</ul>
<p>通过理解和应用这两个概念，可以显著提高代码的可维护性和可扩展性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yichen10.github.io/2024/11/05/%E9%9D%A2%E8%AF%955-spring%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/" data-id="cm33t3dq40000bwbz195sd2gs" data-title="面试5-spring基础相关" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/11/05/%E9%9D%A2%E8%AF%954/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">面试4</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%955-spring%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/">面试5-spring基础相关</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%954/">面试4</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%953/">面试3</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%952/">面试2</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%951/">面试1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 yichen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>