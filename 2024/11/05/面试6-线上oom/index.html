<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面试6-线上oom | 一尘的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Java线上出现OOM，如何处理内存过高一般有两种情况：内存溢出和内存泄露线上排查：1.系统已经挂掉了，-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;path&#x2F;to&#x2F;heapdump.hprof导出oom日志到本地，使用VisualVM分析，有个标签为抽样器，可以看到哪个类占用的大小，，哪一个类占用了多少">
<meta property="og:type" content="article">
<meta property="og:title" content="面试6-线上oom">
<meta property="og:url" content="https://yichen10.github.io/2024/11/05/%E9%9D%A2%E8%AF%956-%E7%BA%BF%E4%B8%8Aoom/index.html">
<meta property="og:site_name" content="一尘的个人博客">
<meta property="og:description" content="Java线上出现OOM，如何处理内存过高一般有两种情况：内存溢出和内存泄露线上排查：1.系统已经挂掉了，-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;path&#x2F;to&#x2F;heapdump.hprof导出oom日志到本地，使用VisualVM分析，有个标签为抽样器，可以看到哪个类占用的大小，，哪一个类占用了多少">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-11-05T09:15:45.000Z">
<meta property="article:modified_time" content="2024-11-05T09:16:07.564Z">
<meta property="article:author" content="yichen">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="一尘的个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">一尘的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yichen10.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-面试6-线上oom" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/05/%E9%9D%A2%E8%AF%956-%E7%BA%BF%E4%B8%8Aoom/" class="article-date">
  <time class="dt-published" datetime="2024-11-05T09:15:45.000Z" itemprop="datePublished">2024-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面试6-线上oom
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Java线上出现OOM，如何处理<br>内存过高一般有两种情况：内存溢出和内存泄露<br>线上排查：<br>1.系统已经挂掉了，-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;path&#x2F;to&#x2F;heapdump.hprof<br>导出oom日志到本地，使用VisualVM分析，有个标签为抽样器，可以看到哪个类占用的大小，<br>，哪一个类占用了多少内存，就会显示出来，点击抽样器，内存，之后就会对远程的那台机器的JAVA进程内存，在图形化界面中显示，有多少个类，占用了多少个字节，这样我们就可以具体定位到是哪个类有问题了<br>2.系统没有挂掉，使用jmap命令，生成堆转储和线程快照，命令为：<br>jmap -dump:live,format&#x3D;b,file&#x3D;&#x2F;path&#x2F;to&#x2F;heapdump.hprof <pid><br>拿到hprof文件后再用VisualVM分析<br>3.使用阿里的开源软件Arthas<br>Arthas 是一个开源的 Java 诊断工具，提供了丰富的命令来监控和诊断 Java 应用程序。你可以通过以下命令安装和启动 Arthas：</p>
<p>curl -O <a target="_blank" rel="noopener" href="https://arthas.aliyun.com/arthas-boot.jar">https://arthas.aliyun.com/arthas-boot.jar</a><br>java -jar arthas-boot.jar<br>Arthas 提供了诸如 dashboard、thread、heapdump 等命令，帮助你实时监控应用程序的运行状态和内存使用情况。</p>
<p>内存溢出： 程序分配的内存超过物理机的内存大小，导致无法继续分配内存，出现OOM报错<br>内存泄露： 不再使用的对象一直占据着内存不释放，导致这块内存浪费掉，久而久之，内存泄露的对象堆积起来，也会导致物理机的内存被耗尽，出现OOM报错<br>内存溢出（Out of Memory, OOM）和内存泄漏（Memory Leak）是 Java 开发中常见的内存管理问题。它们可能导致应用程序崩溃或性能下降。下面分别介绍这两种问题的场景、原因以及解决方法。</p>
<h3 id="内存溢出（Out-of-Memory-OOM）"><a href="#内存溢出（Out-of-Memory-OOM）" class="headerlink" title="内存溢出（Out of Memory, OOM）"></a>内存溢出（Out of Memory, OOM）</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>内存溢出通常发生在应用程序尝试分配的内存超过了 JVM 可用的最大内存限制时。常见的场景包括：</p>
<ol>
<li><strong>大对象分配</strong>：应用程序创建了大量的大对象，导致堆内存不足。</li>
<li><strong>无限递归</strong>：递归调用没有终止条件，导致栈内存溢出。</li>
<li><strong>内存泄漏</strong>：内存泄漏导致堆内存逐渐耗尽。</li>
</ol>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li><strong>增加 JVM 内存</strong>：通过调整 JVM 参数（如 <code>-Xmx</code> 和 <code>-Xms</code>）来增加堆内存大小。</li>
<li><strong>优化代码</strong>：检查代码中是否有大对象分配或无限递归的情况，并进行优化。</li>
<li><strong>使用内存分析工具</strong>：如 VisualVM、MAT（Memory Analyzer Tool）等，分析内存使用情况，找出内存占用过大的对象。</li>
</ol>
<h3 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h3><h4 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h4><p>内存泄漏是指应用程序中不再使用的对象仍然被引用，导致垃圾回收器无法回收这些对象，从而导致内存占用逐渐增加。常见的场景包括：</p>
<ol>
<li><strong>静态集合类</strong>：静态集合类（如 <code>static List</code>）中的对象不会被垃圾回收。</li>
<li><strong>未关闭的资源</strong>：如数据库连接、文件流等未关闭，导致资源无法释放。</li>
<li><strong>内部类引用外部类</strong>：内部类持有外部类的引用，导致外部类无法被回收。</li>
<li><strong>缓存</strong>：缓存中的对象未及时清理，导致内存占用过高。</li>
</ol>
<h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li><strong>避免使用静态集合类</strong>：尽量减少静态集合类的使用，或者在使用后及时清理。</li>
<li><strong>及时关闭资源</strong>：确保在使用完资源后及时关闭，如数据库连接、文件流等。</li>
<li><strong>弱引用</strong>：使用弱引用（<code>WeakReference</code>）来持有对象，避免对象无法被垃圾回收。</li>
<li><strong>定期清理缓存</strong>：对于缓存中的对象，定期进行清理，避免内存占用过高。</li>
<li><strong>使用内存分析工具</strong>：如 VisualVM、MAT 等，分析内存泄漏的原因，找出未被回收的对象。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="内存溢出示例"><a href="#内存溢出示例" class="headerlink" title="内存溢出示例"></a>内存溢出示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 分配 1MB 的内存</span></span><br><span class="line">            list.add(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，程序不断分配内存，最终会导致内存溢出。可以通过增加 JVM 内存或优化代码来解决。</p>
<h4 id="内存泄漏示例"><a href="#内存泄漏示例" class="headerlink" title="内存泄漏示例"></a>内存泄漏示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeakExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            list.add(obj);</span><br><span class="line">            <span class="comment">// 忘记清理 list</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，静态集合 <code>list</code> 不断添加对象，导致内存泄漏。可以通过定期清理 <code>list</code> 或使用弱引用来解决。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内存溢出和内存泄漏是 Java 开发中常见的内存管理问题。通过合理调整 JVM 参数、优化代码、使用内存分析工具等方法，可以有效避免和解决这些问题，提升应用程序的稳定性和性能。</p>
<p><code>ArrayList</code> 和 <code>LinkedList</code> 是 Java 中常用的两种集合类，它们都实现了 <code>List</code> 接口，但在底层实现和使用场景上有很大的区别。</p>
<h3 id="1-底层实现"><a href="#1-底层实现" class="headerlink" title="1. 底层实现"></a>1. 底层实现</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul>
<li><strong>底层实现</strong>：<code>ArrayList</code> 是基于动态数组实现的。它内部维护了一个数组，用于存储元素。</li>
<li><strong>扩容机制</strong>：当数组容量不足时，<code>ArrayList</code> 会创建一个更大的数组，并将原数组中的元素复制到新数组中。默认情况下，新数组的容量是原数组容量的 1.5 倍。</li>
<li><strong>随机访问</strong>：由于是基于数组实现的，<code>ArrayList</code> 支持高效的随机访问（通过索引直接访问元素），时间复杂度为 O(1)。</li>
</ul>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li><strong>底层实现</strong>：<code>LinkedList</code> 是基于双向链表实现的。每个节点（Node）包含一个数据元素、一个指向前一个节点的指针（prev）和一个指向后一个节点的指针（next）。</li>
<li><strong>插入和删除</strong>：由于是链表结构，<code>LinkedList</code> 在插入和删除元素时不需要移动其他元素，只需要调整相邻节点的指针，因此插入和删除操作的时间复杂度为 O(1)（在已知节点位置的情况下）。</li>
<li><strong>随机访问</strong>：由于是链表结构，<code>LinkedList</code> 不支持高效的随机访问，访问某个元素需要从头或尾遍历链表，时间复杂度为 O(n)。</li>
</ul>
<h3 id="2-性能差异"><a href="#2-性能差异" class="headerlink" title="2. 性能差异"></a>2. 性能差异</h3><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><ul>
<li><strong>ArrayList</strong>：随机访问非常快，时间复杂度为 O(1)。</li>
<li><strong>LinkedList</strong>：随机访问较慢，时间复杂度为 O(n)。</li>
</ul>
<h4 id="插入和删除元素"><a href="#插入和删除元素" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h4><ul>
<li><strong>ArrayList</strong>：在末尾插入或删除元素较快，时间复杂度为 O(1)；但在中间或开头插入或删除元素较慢，因为需要移动后续元素，时间复杂度为 O(n)。</li>
<li><strong>LinkedList</strong>：在任意位置插入或删除元素都较快，时间复杂度为 O(1)（在已知节点位置的情况下）。</li>
</ul>
<h3 id="3-内存占用"><a href="#3-内存占用" class="headerlink" title="3. 内存占用"></a>3. 内存占用</h3><ul>
<li><strong>ArrayList</strong>：内存占用相对较低，因为数组是连续的内存块。</li>
<li><strong>LinkedList</strong>：内存占用相对较高，因为每个节点都需要额外的指针来维护前后节点的关系。</li>
</ul>
<h3 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h3><ul>
<li><strong>ArrayList</strong>：适用于需要频繁随机访问元素的场景，或者在末尾插入和删除元素的场景。</li>
<li><strong>LinkedList</strong>：适用于需要频繁在中间或开头插入和删除元素的场景。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>ArrayList</strong>：基于数组，支持高效的随机访问，但在中间插入和删除元素较慢。</li>
<li><strong>LinkedList</strong>：基于链表，支持高效的插入和删除操作，但随机访问较慢。</li>
</ul>
<p>选择哪种集合类取决于具体的应用场景和操作需求。</p>
<p>mybatis中，传入表名，如何预防SQL注入</p>
<p>总结<br>白名单机制：通过预定义合法表名，限制传入的表名只能是合法的。</p>
<p>Provider 机制：在运行时动态生成 SQL 语句，并在生成过程中进行参数校验。</p>
<p>Interceptor 机制：在 SQL 执行前对传入的参数进行校验和处理。</p>
<p>通过这些方法，可以有效防止 SQL 注入，确保传入的表名是安全的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yichen10.github.io/2024/11/05/%E9%9D%A2%E8%AF%956-%E7%BA%BF%E4%B8%8Aoom/" data-id="cm348k7uo0000wgbz4iredjbi" data-title="面试6-线上oom" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/11/05/%E9%9D%A2%E8%AF%955-spring%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">面试5-spring基础相关</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%956-%E7%BA%BF%E4%B8%8Aoom/">面试6-线上oom</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%955-spring%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/">面试5-spring基础相关</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%954/">面试4</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%953/">面试3</a>
          </li>
        
          <li>
            <a href="/2024/11/05/%E9%9D%A2%E8%AF%952/">面试2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 yichen<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>